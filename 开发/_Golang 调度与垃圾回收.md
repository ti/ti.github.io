# Golang 调度机制和垃圾回收（GC）机制

## 调度器

主要基于三个基本对象上，G，M，P（定义在源码的src/runtime/runtime.h文件中）
1. G代表一个goroutine对象，每次Go调用的时候，都会创建一个G对象
2. M代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行
3. P代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样
P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改； M的个数和P的个数不一定一样多（会有休眠的M或者不需要太多的M）（最大10000）；每一个P保存着本地G任务队列，也有一个全局G任务队列；


并发控制，超时控制，锁粒度控制，GC 调优，性能调优。


## golang的垃圾回收（GC）机制

golang的垃圾回收采用的是 标记-清理（Mark-and-Sweep） 算法
就是先标记出需要回收的内存对象快，然后在清理掉；

触发GC机制
1.在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）
2.监控线程发现上次GC的时间已经超过两分钟了，触发；将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）
 
每当触发的时候，在主GC线程中就会走如下的GC流程：
1.stop the world，等待所有的M休眠；此时所有的业务逻辑代码都停止
2.标记：分配gc标记任务，唤醒 gcproc个 M（就是第一步休眠的那些），分别做这个，直到所有的M都做完，才结束；并且所有M再次进入休眠
3.清理：有一个单独的goroutine去清理已经标记的内存对象快
4.start the world，设置gcwaiting=0，唤醒所有的M（不会超过P个数）

## 对于上面的三个步骤，分别解释：





## 手动GC

```go
debug.FreeOSMemory()
```