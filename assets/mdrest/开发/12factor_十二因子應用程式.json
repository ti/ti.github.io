{"date":"2014-02-01T00:00:00Z","html":"\u003ch2 id=\"the-12-factor-app\"\u003eThe 12 Factor App\u003c/h2\u003e\n\n\u003cp\u003e“十二因子应用程式”源自于\u003ca href=\"https://www.heroku.com/\"\u003eHeroku\u003c/a\u003e开发团队在收集及观察大量的SaaS(Software as a Service)应用程式开发与执行过程之后，所整理出来的十二条开发SaaS应用程式时的方针。\u003c/p\u003e\n\n\u003cp\u003e遵守这些方针可以增进应用程式本身的稳定性及扩充性(Scalibility)，从程式开发的到系统上线过程也会快捷很多。\u003c/p\u003e\n\n\u003cp\u003e原文：\u003ca href=\"http://www.the12factorapp.com/\"\u003eThe 12 Factor App\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"i-程式码-codebase\"\u003ei. 程式码(Codebase)\u003c/h2\u003e\n\n\u003ch4 id=\"一对一的程式码版本管理\"\u003e一对一的程式码版本管理\u003c/h4\u003e\n\n\u003cp\u003e“十二因子”的程式码必须储存在原始码版本管理系统，例如Git, Subversion. 程式码(codebase)与应用程式(application) 应该以“ㄧ对一”的关系储存着：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e如果你的系统需要有多个原始码管理系统，那你的系统就是个分散式系统(Distributed System)， 分散式系统由多个应用程式(application)组成，而这些应用程式都应各别套用“十二因子”。\u003c/li\u003e\n\u003cli\u003e“十二因子”反对一套程式的原始码有多个应用程式在使用。如果需要分享部分的程式码，正确的解决方式应该为把共享的程式码包装成程式库(library, 例如JAVA的.jar档案)， 然后有需要的其他应用程式以“相依性”(dependency)的程式库来使用。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e每个\u0026rdquo;十二因子应用程式“都有属于它专属的程式码，透过专有的原始码版本管理，可以清楚的安装(deploy)在不同的环境。也许每个环境有不同的版本，但每个系统的所拥有的程式码还是非常清楚干净的。有问题出现时，也可以简单的回朔到之前的版本去。\u003c/p\u003e\n\n\u003ch2 id=\"ii-相依性-dependencies\"\u003eii. 相依性(dependencies)\u003c/h2\u003e\n\n\u003ch4 id=\"明确定义所有相依的程式库-library\"\u003e明确定义所有相依的程式库(library)\u003c/h4\u003e\n\n\u003cp\u003e程式语言通常都会有专属的包装(packaging)与相依性程式库管理系统，例如Java的Maven，或是Ruby的Rubygems。“十二因子”要求应用程式必须使用类似的管理系统，而且所有的第三方程式库必须都明确定义出来，即使有些来自系统的程式库也应列出来管理。这样一来当新的工程师加入开发时，随时都可以透过管理系统简单的安装该程式在自己的环境，无论是任何平台都不会有冲突。\u003c/p\u003e\n\n\u003cp\u003e一般来说容易被疏忽的部分是系统本身的程式库或是工具，“十二因子应用程式”必须将这些有相依性的程式以第三方程式库的方式安装，以避免应用程式被安装在不支援的系统上。例如Linux的curl command如果直接在程式码里面使用，那这个应用程式有无法轻易的安装在windows的环境。\u003c/p\u003e\n\n\u003ch2 id=\"iii-配置变数-config\"\u003eiii. 配置变数(Config)\u003c/h2\u003e\n\n\u003ch4 id=\"将配置变数-config-储存在环境变数-environment-variables\"\u003e将配置变数(Config)储存在环境变数(Environment Variables)\u003c/h4\u003e\n\n\u003cp\u003e配置变数(Config)所指的是每个应用软体在不同的安装环境(例如production vs QA)会设定的变数。\u003c/p\u003e\n\n\u003cp\u003e一般常见的例子：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e资料库的连结设定，例如URL，帐号，密码。\u003c/li\u003e\n\u003cli\u003e第三方服务的连结设定，例如Facebook API的URL，帐号，密码等。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e“十二因子应用程式”反对将这些配置变数储存在原始码里面。建议的所有的配置变数应该储存在环境变数(Environment Variables)中。将配置变数储存在原始码中会有安全性的问题，一但程式码开放给其他团体或个人时，这些机密的帐号密码也容易不小心外泄。另外配置变数是随着环境在改变的，而应用程式的程式码跟版本的关系是固定的，同版本的应用程式在任何安装的环境都是一样的， 所以配置变数需要另外管理。一般来说要个别定义在伺服器的环境变数中，如此也可以改善应用程式的扩充性(Scalability)。\u003c/p\u003e\n\n\u003cp\u003e有些应用程式有属于该程式结构使用的变数，例如Java Spring的config。这类的变数必须和程式码共生，而不在以上提到的“十二因子”的规范内。\u003c/p\u003e\n\n\u003ch2 id=\"iv-后端支援服务-backing-services\"\u003eiv. 后端支援服务(Backing Services)\u003c/h2\u003e\n\n\u003ch4 id=\"所有后端支援系统都应视为外接的资源\"\u003e所有后端支援系统都应视为外接的资源\u003c/h4\u003e\n\n\u003cp\u003e所谓的后端支援服务(backing service)是指于应用程式透过网路传输得到的服务，例如资料库，SMTP，快速储存记忆体(cache)，API(Facebook,Google)之类的服务。\u003c/p\u003e\n\n\u003cp\u003e负责管理这些支援服务的种类主要有本地的(local)跟第三方(3rd party)，例如资料库通常是同公司的系统工程师在管理。但如果主机架在云端，大多数服务就都是透过第三方提供的了。“十二因子”的程式码对待所有这些服务的种类必须是一致的，所有的后端支援系统，无论是本地管理或是第三方管理， 都一律视为外接的资源，用一样的程式码来执行。唯一不同的地方只有连线的方式，url，帐号，密码透过Config来管理。\u003c/p\u003e\n\n\u003cp\u003e由于程式码一致，“十二因子应用程式“可以简单的切换提供服务的来源。例如：如果要把MySQL提供者从自己local的换到Amazon提供的，只要改连结的资料可以了。或是要把Gmail 的SMTP 换成Yahoo! 的，也只要改连结的资料。关键就在于”十二因子“的程式码一律视这些后端支援服务为外接的资源，无论是本地管理还是第三方管理的。\u003c/p\u003e\n\n\u003ch2 id=\"v-构建-发行-执行-build-release-run\"\u003ev. 构建，发行，执行(Build,Release,Run)\u003c/h2\u003e\n\n\u003ch4 id=\"确实分离建构与执行的阶段\"\u003e确实分离建构与执行的阶段\u003c/h4\u003e\n\n\u003cp\u003e应用程式的从程式码到发行(Release)与执行可以分为以下三阶段：\u003c/p\u003e\n\n\u003cp\u003e第一阶段：“构建”(Build)，所指的是透过构建系统将程式码及有相依性的程式库包装起来在一起。例如将package JAVA程式为.jar或是.war档。\u003c/p\u003e\n\n\u003cp\u003e第二阶段：“发行”(Release)，将包装好的程式库，加上环境特有的配置变数(Config)，透过发行管理系统将档案上传至要执行的环境里面。一般来说发行管理系统另的一个主要工作是将每个发行版本(Release Version)规范定义好。每一个不同版本的程式码都应有对应的发行版本， 版本定义可以用日期(2012-1-1-11:59:01)或是渐进的数字(v1.1.3)来定义。\u003c/p\u003e\n\n\u003cp\u003e第三阶段：“执行”(Run)，所指的是发行的版本(包含code+config)，在该环境中执行。\u003c/p\u003e\n\n\u003cp\u003e“十二因子应用程式”强调这三个阶段必须清楚地分开与定义好。例如在执行阶段不容许有任何的程式码改变。如果这三个阶段可以分别设定好， 应用程式就可以进入自动化的发行与执行，工程师开发新的功能，构建系统自动包装，发行系统自动定义版本，然后新版本的应用程式跟config一起发行到执行的环境中。出问题时也可以在发行系统中选择之前的版本回朔回去。\u003c/p\u003e\n\n\u003ch2 id=\"vi-处理序-processes\"\u003evi. 处理序(Processes)\u003c/h2\u003e\n\n\u003ch4 id=\"应用程式必须以-无状态-的方式在处理序上执行\"\u003e应用程式必须以“无状态”的方式在处理序上执行\u003c/h4\u003e\n\n\u003cp\u003e一般应用程式会在一个或多个处理序(Process)上执行，例如在工程师的local开发环境通常会用一个处理序，而正式上线时系统通常会有多个处理序来执行。\u003c/p\u003e\n\n\u003cp\u003e”无状态“(Stateless)指的是应用程式不会有预设任何的状态，每个request在执行完后，执行过程中所用到的状态(State)都不会被储存下来。\u003c/p\u003e\n\n\u003cp\u003e执行”十二因子应用程式“的处理序绝对是”无状态“且不直接分享资料的，每个处理序之间不会有任何的沟通，也不会预设互通的状态。有需要互通的资料一律由后端支援服务(Backing Service)储存，例如资料库或是快速储存记忆体(cache)。因为应用程式会由多个处理序执行，而无法预期下个request来时会由哪一个处理序执行。唯有透过共通的Backing Service，才可以确保资料的完整性。\u003c/p\u003e\n\n\u003cp\u003e另外应用程式可以在上线(Live)的状态下随时增加处理序甚至是新的硬体，如果依靠暂存的记忆体，则无法保证执行所需的资料的完整性。例如说一般常见的http session，就不应该直接储存在记忆体里面，而应该利用可设定自动失效的Memcached或是Redis来储存。\u003c/p\u003e\n\n\u003ch2 id=\"vii-连接埠-port-binding\"\u003evii. 连接埠(Port Binding)\u003c/h2\u003e\n\n\u003ch4 id=\"透过连接埠提供对外服务\"\u003e透过连接埠提供对外服务\u003c/h4\u003e\n\n\u003cp\u003e”十二因子应用程式“的服务一律都已完整定义在程式码中，要对外提供服务时，只要网路伺服器透过连接埠就可以执行。例如一般的Java的网页通常是透过Tomcat或是Jetty之类的伺服器，将连接埠绑在8080上，对外就可以透过对外路径设定(Route)到该应用程式上。如果在本地一般就是直接连上\u003ca href=\"http://localhost:8080/。由于是透过伺服器的连接埠来定义上线的程式，一个伺服器也可以同时拥有多个应用程式。一个常见的例子就是一个伺服器同时有客户(Customer)使用的应用程式跟管理者(Admin)使用的应用程式，只是绑在不同的连接埠上罢了。\"\u003ehttp://localhost:8080/。由于是透过伺服器的连接埠来定义上线的程式，一个伺服器也可以同时拥有多个应用程式。一个常见的例子就是一个伺服器同时有客户(Customer)使用的应用程式跟管理者(Admin)使用的应用程式，只是绑在不同的连接埠上罢了。\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e连接埠的应用不只限于网页程式，也可以是各种的网路服务，例如FTP，或是各种客制的服务。”十二因子应用程式“也可以成为其他应用程式的”后端支援服务“(Backing Service)，例如很多应用程式本生的服务只有有提供Restful API，而没有任何使用者界面。\u003c/p\u003e\n\n\u003ch2 id=\"viii-同步执行-concurrency\"\u003eviii. 同步执行(Concurrency)\u003c/h2\u003e\n\n\u003ch4 id=\"透过同步执行来加速应用程式\"\u003e透过同步执行来加速应用程式\u003c/h4\u003e\n\n\u003cp\u003e一般程式的执行环境都支援使用多数处理序(Process)来执行应用程式，例如JAVA的JVM就是透过Thread让软体同步执行多项作业(Task)。\u003c/p\u003e\n\n\u003cp\u003e“十二因子应用程式”利用这些同步执行的工能来增进应用程式的效率跟扩充性(Scalability)。例如Http Request由一个处理序执行， 需要定期执行的作业由另一个处理序执行。\u003c/p\u003e\n\n\u003cp\u003e这样的设计配合“十二因子”中的无状态(Stateless)跟不直接分享执行资源的原则，应用程式则可以简单地透过增加硬体资源或云端上的执行单位来最佳化(Optimize)执行的效能。\u003c/p\u003e\n\n\u003ch2 id=\"ix-快捷启用与终止-disposability\"\u003eix. 快捷启用与终止(Disposability)\u003c/h2\u003e\n\n\u003ch4 id=\"达到快速启用与安全终止服务\"\u003e达到快速启用与安全终止服务\u003c/h4\u003e\n\n\u003cp\u003e“十二因子应用程式”在开发的任何阶段，都要确实的保持程式启动的速度，同时要确保程式终止时不会有无法复原或失去重要资料的状况。如果可以保持这两个原则，应用程式本身就可以简单的达到扩充性(Scalibility)，或者是硬体迁移(Migration)的过程也会简化很多。\u003c/p\u003e\n\n\u003cp\u003e应用程式的启用时间应该要可以在几秒内完成，这样除了当流量变大时，可以快速的增加执行的单位，另外在构建跟发行的过程也会快速很多， 更新的版本可以快速的上线。\u003c/p\u003e\n\n\u003cp\u003e应用程式在终止时要确认资料跟作业的完整度，透过后端支援服务(Backing Service)来分享状态，这样当一个处理序终止后，其他执行中的处理序也可以接着完成作业。例如有些程式有很多在后端执行的作业，可以透过Queuing Service(例如RabbitMQ)来分配要执行的工作， 而无论哪一个处理序都可以分别的执行，这样应用程式才可以个别安全的终止服务。\u003c/p\u003e\n\n\u003ch2 id=\"x-环境的一致性-dev-prod-parity\"\u003ex. 环境的一致性(Dev/Prod Parity)\u003c/h2\u003e\n\n\u003ch4 id=\"保持不同环境-dev-qa-staging-production-的一致性\"\u003e保持不同环境(Dev，QA，Staging，Production)的一致性\u003c/h4\u003e\n\n\u003cp\u003e传统应用软体的开发环境(Dev)通常会跟Production环境不同，通常原因可能是资源跟人员的分配的差异性。这差异性会造成三个软体开发的落差：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e时间：从工程师的软体开发环境到可以发行到production需要很长的时间，有时候要几周甚至几个月才可以发行新的版本。\u003c/li\u003e\n\u003cli\u003e人力资源：软体工程师负责开发软体，需要透过系统工程师来发行软体到production环境。\u003c/li\u003e\n\u003cli\u003e工具：软体工程师在开发时使用较轻便的工具，而production环境则使用功能较完整的工具。例如工程师用SQLite开发，而production用MySQL\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e“十二因子应用程式” 强调“无间断的发行环境”(Continous Deployment)，发行的环境设定一律自动化，测试过的新功能会包装成米你的版本自动发行到production， 有时一天发行一个版本，有时甚至可以一天发行多个版本。\u003c/p\u003e\n\n\u003cp\u003e另外“十二因子应用程式” 强调任何环境都应该使用相同的工具或后端支援服务(Backing Service)，例如资料库或是Cache。如果工具不同，会发生新版本在开发环境测试都通过了，但发行到production就出现问题的状况。如果真正要确保“无间断发行”的稳定性，就要尽量达到在各环境都使用与production一样的工具或后端服务。\u003c/p\u003e\n\n\u003cp\u003e谨守“十二因子”的原则，则应用程式开发的环境就会稳定很多，且之前提到的落差就会减低：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e时间：从开发到发行时间减为一天内。\u003c/li\u003e\n\u003cli\u003e人力资源：发行环境设定好后，软体工程师就可以自行发行新版本，不需要透过系统工程师。\u003c/li\u003e\n\u003cli\u003e工具：任何环境的工具都与production的一样。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"xi-记录-logs\"\u003exi. 记录(Logs)\u003c/h2\u003e\n\n\u003ch4 id=\"透过外接服务将记录整合起来\"\u003e透过外接服务将记录整合起来\u003c/h4\u003e\n\n\u003cp\u003e应用程式的执行过程通常都是透过记录(Logs)储存起来，一般的储存方式为将记录写在伺服器的档案内，一旦记录档(Log file)开启后， 应用程式的执行内容就会一行一行的写在档案内，在程式终止前都会不断的记录着程式开发者认为重要的讯息，例如错误资讯或是未来可以用来分析的资料。由于SAAS的应用程式通常会在多个主机上执行，造成记录档案很可能处于不连续的状态，所以需要有额外的服务来将记录整合起来。\u003c/p\u003e\n\n\u003cp\u003e“十二因子应用程式”本身不管理任何关于整合记录的服务，将这类整合的任务交给执行环境去处理。“十二因子”只负责将记录写入该执行环境的记录档内。\u003c/p\u003e\n\n\u003cp\u003e目前已有很多整合记录档的工具(例如Logplex或是Fluent)，这些工具可以将每个主机上的记录档传输到在单一伺服器上，将每笔记录的内容依据发生时间整合起来， 提供未来除错或是分析使用。\u003c/p\u003e\n\n\u003ch2 id=\"xii-系统管理者-admin-processes\"\u003exii. 系统管理者(Admin Processes)\u003c/h2\u003e\n\n\u003ch4 id=\"在相同环境下执行管理者作业-task\"\u003e在相同环境下执行管理者作业(Task)\u003c/h4\u003e\n\n\u003cp\u003e应用程式在上线一段时间过后，难免需要执行一些管理者(Admin)的作业，例如资料库迁移，或是需要登录控制台(Admin Console)之类的界面管理系统资料之类的。有时候工程师为了方便，在local环境执行更新其他环境的工作，这样的结果会造成应用程式本身的不稳定，且严重影响程式码版本的一致性。\u003c/p\u003e\n\n\u003cp\u003e“十二因子应用程式”的管理者作业必须跟程式本身在同一个环境执行，例如在QA的环境执行QA的管理作业，production的管理作业就在production环境执行。关于管理者作业的程式码必须跟应用程式本身的程式码以同一个版本发行(Release)到该环境，配合该环境的配置变数(Config)来执行。\u003c/p\u003e\n","location":"开发/12factor_十二因子應用程式","tags":["程序","12因子"],"title":"十二因子应用程式\n"}