{"date":"2017-04-02T00:00:00Z","html":"\u003cp\u003e\u003ca href=\"http://nsq.io\"\u003eNSQ\u003c/a\u003e是实时的分布式消息处理平台，用于大规模系统中的实时消息服务，并且每天能够处理数亿级别的消息，其设计目标是为在分布式环境下运行的去中心化服务提供一个强大的基础架构。\u003c/p\u003e\n\n\u003ch2 id=\"快速入门\"\u003e快速入门\u003c/h2\u003e\n\n\u003ch3 id=\"nsq-安装\"\u003eNSQ 安装\u003c/h3\u003e\n\n\u003cp\u003edocker-compose.yml\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eversion: '3'\nservices:\n  nsqlookupd:\n    image: nsqio/nsq\n    command: /nsqlookupd\n    ports:\n      - \u0026quot;4160\u0026quot;\n      - \u0026quot;4161\u0026quot;\n  nsqd:\n    image: nsqio/nsq\n    command: /nsqd --lookupd-tcp-address=nsqlookupd:4160\n    depends_on:\n      - nsqlookupd\n    ports:\n      - \u0026quot;4150\u0026quot;\n      - \u0026quot;4151\u0026quot;\n  nsqadmin:\n    image: nsqio/nsq\n    command: /nsqadmin --lookupd-http-address=nsqlookupd:4161\n    depends_on:\n      - nsqlookupd  \n    ports:\n      - \u0026quot;4171\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edocker-compose up -d\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003edocker-compose ps\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003ehttp://127.0.0.1:4171 (docker 外部映射端口可能不一致，具体查看docker-compose ps中对应的端口地址)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"nsq主要组件\"\u003eNSQ主要组件\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://nsq.io/components/nsqd.html\"\u003ensqd\u003c/a\u003e：一个负责接收、排队、转发消息到客户端的守护进程\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://nsq.io/components/nsqlookupd.html\"\u003ensqlookupd\u003c/a\u003e：管理拓扑信息并提供最终一致性的发现服务的守护进程\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://nsq.io/components/nsqadmin.html\"\u003ensqadmin\u003c/a\u003e：一套Web用户界面，可实时查看集群的统计数据和执行各种各样的管理任务\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://nsq.io/components/utilities.html\"\u003eutilities\u003c/a\u003e：常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"nsq核心概念\"\u003eNSQ核心概念\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTopic\u003c/strong\u003e：一个topic就是程序发布消息的一个逻辑键，当程序第一次发布消息时就会创建topic。\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eChannels\u003c/strong\u003e channel组与消费者相关，是消费者之间的负载均衡，channel在某种意义上来说是一个“队列”。每当一个发布者发送一条消息到一个topic，消息会被复制到所有消费者连接的channel上，消费者通过这个特殊的channel读取消息，实际上，在消费者第一次订阅时就会创建channel。\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eChannel会将消息进行排列，如果没有消费者读取消息，消息首先会在内存中排队，当量太大时就会被保存到磁盘中。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMessage\u003c/strong\u003e 消息构成了我们数据流的中坚力量，消费者可以选择结束消息，表明它们正在被正常处理，或者重新将他们排队待到后面再进行处理。每个消息包含传递尝试的次数，当消息传递超过一定的阀值次数时，我们应该放弃这些消息，或者作为额外消息进行处理。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"nsq是怎样运行的\"\u003eNSQ是怎样运行的\u003c/h3\u003e\n\n\u003cp\u003eNSQ在操作期间同样运行着两个程序：\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNsqd\u003c/strong\u003e ——nsqd守护进程是NSQ的核心部分，它是一个单独的监听某个端口进来的消息的二进制程序。每个nsqd节点都独立运行，不共享任何状态。当一个节点启动时，它向一组nsqlookupd节点进行注册操作，并将保存在此节点上的topic和channel进行广播。\u003c/p\u003e\n\n\u003cp\u003e客户端可以发布消息到nsqd守护进程上，或者从nsqd守护进程上读取消息。通常，消息发布者会向一个单一的local nsqd发布消息，消费者从连接了的一组nsqd节点的topic上远程读取消息。如果你不关心动态添加节点功能，你可以直接运行standalone模式。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNsqlookupd\u003c/strong\u003e ——nsqlookupd服务器像consul或etcd那样工作，只是它被设计得没有协调和强一致性能力。每个nsqlookupd都作为nsqd节点注册信息的短暂数据存储区。消费者连接这些节点去检测需要从哪个nsqd节点上读取消息。\u003c/p\u003e\n\n\u003ch3 id=\"nsq消息的生命周期\"\u003eNSQ消息的生命周期\u003c/h3\u003e\n\n\u003cp\u003eNSQ提倡生产者与nsqd尽量在同一个实例环境中。生产者不需要负责发现其他的nsqd实例, 它们只管往自己的nsqd中投放消息。\n  \u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/nsq/img/nsq.gif\" alt=\"nsq_01\"/\u003e\u003c/div\u003e\nNSQ具体的消息流程如下：\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e生产者往本地的nsqd中发送消息，这个过程会开启一个连接，并发送一个带有topic和消息体的PUB的命令到nsqd中。我们假如是发送一个events的topic\u003c/li\u003e\n\u003cli\u003eevents topic 会对消息进行copy,并多路发送到各个channel中, 我们假设有三个channel, 那么这个流程会如下图描述所示:\n\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/nsq/img/nsq_01.png\" alt=\"nsq_01\"/\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003echannel中的每条消息会被放进队列中, 直到消息被worker所消费掉, 如果队列占用的内存超出限制, 消息会被写进硬盘\u003c/li\u003e\n\u003cli\u003ensqd节点会首先向nsqlookd节点广播它的位置信息, 一旦这些信息被nsqlookupd注册上, workers就会发现这些nsqd节点,包括这些节点的events topic，相关过程如下图\n\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/nsq/img/nsq_02.png\" alt=\"nsq_01\"/\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e每个worker向每个nsqd主机进行订阅操作，用于表明worker已经准备好接受消息了。这里我们不需要一个完整的连通图，但我们必须要保证每个单独的nsqd实例拥有足够的消费者去消费它们的消息，否则channel会被队列堆着。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"nsq-为什么是可靠的\"\u003eNSQ 为什么是可靠的\u003c/h3\u003e\n\n\u003cp\u003e在生产环境中，我们几乎在我们所有的实例中运行nsqd守护程序，发布者之间协同定位。NSQ在实际生产中运行良好有几个原因：\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e简单的协议\u003c/strong\u003e ——如果你的队列已经有了一个很好的客户端库，这个不是一个很大的问题，但如果你现在的客户端库存在bug或者过时了，一个简单的协议就能体现出优势了。\u003c/p\u003e\n\n\u003cp\u003eNSQ有一个快速的二进制协议，通过短短的几天工作量就可以很简单地实现这些协议，我们还自己创建了我们的纯JS驱动（当时只存在coffeescript驱动），这个纯JS驱动运行的很稳定可靠。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e运行简单\u003c/strong\u003e ——NSQ没有复杂的水印设置或JVM级别的配置，相反，你可以配置保存到内存中的消息的数量和消息最大值，如果队列被消息填满了，消息会被保存到磁盘上。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e分布式\u003c/strong\u003e ——因为NSQ没有在守护程序之间共享信息，所以它从一开始就是为了分布式操作而生。个别的机器可以随便宕机随便启动而不会影响到系统的其余部分，消息发布者可以在本地发布，即使面对网络分区。\u003c/p\u003e\n\n\u003ch3 id=\"nsq常见部署方式\"\u003eNSQ常见部署方式\u003c/h3\u003e\n\n\u003cp\u003e启动nsqlookupd\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003ensqlookupd\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e运行两个测试的nsqd实例\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003emkdir -p /tmp/nsq/data1    #正式环境请不要放在临时目录\nnsqd --lookupd-tcp-address=localhost:4160 --data-path=/tmp/nsq/data1\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e运行前端监控\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003ensqadmin --lookupd-http-address=localhost:4161\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e默认情况下, 可以在浏览器输入: host-name:4171 打开监控面板\u003c/p\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/nsq/img/nsq_03.png\" alt=\"nsq_01\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003cp\u003e由于nsq提供了一个unix-like的工具,所以我们可以在终端使用以下命令进行消息的发送测试:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecurl -d 'hello world 1' 'http://127.0.0.1:4151/pub?topic=topic_test'\ncurl -d 'hello world 2' 'http://127.0.0.1:4151/pub?topic=topic_test'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e发送后, 可以在监控面板观察页面数据的变化。\u003c/p\u003e\n\n\u003ch3 id=\"简单示例代码\"\u003e简单示例代码\u003c/h3\u003e\n\n\u003cp\u003e生产者\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\nimport (\n\t\u0026quot;log\u0026quot;\n\t\u0026quot;github.com/nsqio/go-nsq\u0026quot;\n)\n\nfunc main() {\n\tconfig := nsq.NewConfig()\n\tw, _ := nsq.NewProducer(\u0026quot;127.0.0.1:4150\u0026quot;, config)\n\terr := w.Publish(\u0026quot;topic_0\u0026quot;, []byte(\u0026quot;test\u0026quot;)) //向topic_0发布消息test\n\tif err != nil {\n\t\tlog.Panic(\u0026quot;Could not connect\u0026quot;)\n\t}\n\tw.Stop()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e消费者\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n\t\u0026quot;log\u0026quot;\n\t\u0026quot;sync\u0026quot;\n\t\u0026quot;github.com/nsqio/go-nsq\u0026quot;\n)\n\nfunc main() {\n\twg := \u0026amp;sync.WaitGroup{}\n\twg.Add(1)\n\tconfig := nsq.NewConfig()\n\tq, _ := nsq.NewConsumer(\u0026quot;topic_0\u0026quot;, \u0026quot;ch\u0026quot;, config)\n\tq.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {\n\t\tlog.Printf(\u0026quot;Got a message: %v\u0026quot;, string(message.Body))\n\t\twg.Done()\n\t\treturn nil\n\t}))\n\terr := q.ConnectToNSQD(\u0026quot;127.0.0.1:4150\u0026quot;)\n\tif err != nil {\n\t\tlog.Panic(\u0026quot;Could not connect\u0026quot;)\n\t}\n\twg.Wait()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"特性和担保\"\u003e特性和担保\u003c/h3\u003e\n\n\u003ch4 id=\"特性\"\u003e特性\u003c/h4\u003e\n\n\u003cul\u003e\n\u003cli\u003e支持无 SPOF 的分布式拓扑\u003c/li\u003e\n\u003cli\u003e水平扩展(没有中间件，无缝地添加更多的节点到集群)\u003c/li\u003e\n\u003cli\u003e低延迟消息传递 (\u003ca href=\"http://wiki.jikexueyuan.com/project/nsq-guide/performance.html\"\u003e性能\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003e结合负载均衡和多播消息路由风格\u003c/li\u003e\n\u003cli\u003e擅长面向流媒体(高通量)和工作(低吞吐量)工作负载\u003c/li\u003e\n\u003cli\u003e主要是内存中(除了高水位线消息透明地保存在磁盘上)\u003c/li\u003e\n\u003cli\u003e运行时发现消费者找到生产者服务(\u003ca href=\"https://github.com/bitly/nsq/tree/master/nsqlookupd/README.md\"\u003ensqlookupd\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003e传输层安全性 (TLS)\u003c/li\u003e\n\u003cli\u003e数据格式不可知\u003c/li\u003e\n\u003cli\u003e一些依赖项(容易部署)和健全的，有界，默认配置\u003c/li\u003e\n\u003cli\u003e任何语言都有简单 TCP 协议支持客户端库\u003c/li\u003e\n\u003cli\u003eHTTP 接口统计、管理行为和生产者(\u003cstrong\u003e不需要客户端库发布\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003e为实时检测集成了 \u003ca href=\"https://github.com/etsy/statsd/\"\u003estatsd\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e健壮的集群管理界面 (\u003ca href=\"https://github.com/bitly/nsq/tree/master/nsqadmin/README.md\"\u003ensqadmin\u003c/a\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"担保\"\u003e担保\u003c/h4\u003e\n\n\u003cp\u003e对于任何分布式系统来说，都是通过智能权衡来实现目标。通过这些透明的可靠性指标，我们希望能使得 NSQ 在部署到产品上的行为是可达预期的。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e消息不可持久化（默认）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e虽然系统支持消息持久化存储在磁盘中（通过 \u003ccode\u003e--mem-queue-size\u003c/code\u003e ），不过默认情况下消息都在\u003cstrong\u003e内存\u003c/strong\u003e中.\u003c/p\u003e\n\n\u003cp\u003e如果将 \u003ccode\u003e--mem-queue-size\u003c/code\u003e 设置为 0，所有的消息将会存储到磁盘。我们不用担心消息会丢失，nsq 内部机制保证在程序关闭时将队列中的数据持久化到硬盘，重启后就会恢复。\u003c/p\u003e\n\n\u003cp\u003eNSQ 没有内置的复制机制，却有各种各样的方法管理这种权衡，比如部署拓扑结构和技术，在容错的时候从属并持久化内容到磁盘。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e消息最少会被投递一次\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如上所述，这个假设成立于 \u003ccode\u003ensqd\u003c/code\u003e 节点没有错误。\u003c/p\u003e\n\n\u003cp\u003e因为各种原因，消息可以被投递多次（客户端超时，连接失效，重新排队，等等）。由客户端负责操作。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e接收到的消息是无序的\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e不要依赖于投递给消费者的消息的顺序。\u003c/p\u003e\n\n\u003cp\u003e和投递消息机制类似，它是由重新队列(requeues)，内存和磁盘存储的混合导致的，实际上，节点间不会共享任何信息。\u003c/p\u003e\n\n\u003cp\u003e它是相对的简单完成\u003cstrong\u003e疏松队列\u003c/strong\u003e，（例如，对于某个消费者来说，消息是有次序的，但是不能给你作为一个整体跨集群），通过使用时间窗来接收消息，并在处理前排序（虽然为了维持这个变量，必须抛弃时间窗外的消息）。\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e消费者最终找出所有话题的生产者\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这个服务(\u003ca href=\"https://github.com/bitly/nsq/tree/master/nsqlookupd/README.md\"\u003ensqlookupd\u003c/a\u003e) 被设计成最终一致性。\u003ccode\u003ensqlookupd\u003c/code\u003e 节点不会维持状态，也不会回答查询。\u003c/p\u003e\n\n\u003cp\u003e网络分区并不会影响可用性，分区的双方仍然能回答查询。部署性拓扑可以显著的减轻这类问题。\u003c/p\u003e\n\n\u003ch3 id=\"不支持的使用场景\"\u003e不支持的使用场景\u003c/h3\u003e\n\n\u003cp\u003ensq大部分情况基本能满足我们作为消息队列的要求,而且性能与单点故障处理能力也比较出色， 但NSQ不能使用于以下场景。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e有顺序要求的消息\u003c/li\u003e\n\u003cli\u003e不支持副本集的集群方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"nsq-性能测试\"\u003eNSQ 性能测试\u003c/h2\u003e\n\n\u003cp\u003e这篇文章主要对NSQ性能做测试。\u003c/p\u003e\n\n\u003ch3 id=\"测试环境\"\u003e测试环境\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e硬件环境\n\n\u003cul\u003e\n\u003cli\u003e处理器名称：Intel Core i5\u003c/li\u003e\n\u003cli\u003e处理器速度： 3.1 GHz\u003c/li\u003e\n\u003cli\u003e处理器数目： 1\u003c/li\u003e\n\u003cli\u003e核总数： 4\u003c/li\u003e\n\u003cli\u003eL2 缓存（每个核）： 256 KB\u003c/li\u003e\n\u003cli\u003eL3 缓存： 4 MB\u003c/li\u003e\n\u003cli\u003e内存： 16 GB\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e软件环境\n\n\u003cul\u003e\n\u003cli\u003e操作系统：macOS 10.12.4 (16E195)\u003c/li\u003e\n\u003cli\u003eGo 语言版本： 1.8.1\u003c/li\u003e\n\u003cli\u003eNSQ版本：1.0.0-compat\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"生产写入性能测试\"\u003e生产写入性能测试\u003c/h3\u003e\n\n\u003cp\u003e插入每条数据大小为200字节\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e运行时间\u003c/th\u003e\n\u003cth align=\"center\"\u003e写入数据\u003c/th\u003e\n\u003cth align=\"center\"\u003e写入速度\u003c/th\u003e\n\u003cth\u003e写入效率\u003c/th\u003e\n\u003cth\u003e耗时(us)/条\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e10秒\u003c/td\u003e\n\u003ctd align=\"center\"\u003e3,278,200\u003c/td\u003e\n\u003ctd align=\"center\"\u003e55.594mb/s\u003c/td\u003e\n\u003ctd\u003e91,474.761/秒\u003c/td\u003e\n\u003ctd\u003e3.431\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e测试脚本：\u003ca href=\"https://github.com/nsqio/nsq/blob/master/bench/bench_writer/bench_writer.go\"\u003ehttps://github.com/nsqio/nsq/blob/master/bench/bench_writer/bench_writer.go\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"消费性能测试\"\u003e消费性能测试\u003c/h3\u003e\n\n\u003cp\u003e每条数据大小为200字节\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e运行时间\u003c/th\u003e\n\u003cth align=\"center\"\u003e读取数据\u003c/th\u003e\n\u003cth align=\"center\"\u003e消费速度\u003c/th\u003e\n\u003cth\u003e读取效率\u003c/th\u003e\n\u003cth\u003e耗时(us)/条\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e10秒\u003c/td\u003e\n\u003ctd align=\"center\"\u003e3,278,200\u003c/td\u003e\n\u003ctd align=\"center\"\u003e58.922mb/s\u003c/td\u003e\n\u003ctd\u003e308,920.325/秒\u003c/td\u003e\n\u003ctd\u003e3.237\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e测试脚本：\u003ca href=\"https://github.com/nsqio/nsq/blob/master/bench/bench_reader/bench_reader.go\"\u003ehttps://github.com/nsqio/nsq/blob/master/bench/bench_reader/bench_reader.go\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"并发单订阅性能测试\"\u003e并发单订阅性能测试\u003c/h3\u003e\n\n\u003cp\u003e插入的数据大小为1字节\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e生产条数\u003c/th\u003e\n\u003cth align=\"center\"\u003e生产耗时（毫秒）\u003c/th\u003e\n\u003cth align=\"center\"\u003e消费耗时（毫秒）\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e10\u003c/td\u003e\n\u003ctd align=\"center\"\u003e1.423013\u003c/td\u003e\n\u003ctd align=\"center\"\u003e1.197299\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e1000\u003c/td\u003e\n\u003ctd align=\"center\"\u003e47.938627\u003c/td\u003e\n\u003ctd align=\"center\"\u003e51.872540\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e10,000\u003c/td\u003e\n\u003ctd align=\"center\"\u003e460.019361\u003c/td\u003e\n\u003ctd align=\"center\"\u003e530.210616\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e100,000\u003c/td\u003e\n\u003ctd align=\"center\"\u003e5976.451920\u003c/td\u003e\n\u003ctd align=\"center\"\u003e6466.993025\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e结论：在当前测试环境，及时消费的情况下每秒可生产消费数据小于2万\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"并发多订阅测试\"\u003e并发多订阅测试\u003c/h3\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e生产条数\u003c/th\u003e\n\u003cth align=\"center\"\u003e生产耗时（毫秒）\u003c/th\u003e\n\u003cth align=\"center\"\u003e消费者1耗时（毫秒）\u003c/th\u003e\n\u003cth align=\"center\"\u003e消费者2耗时（毫秒）\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e10\u003c/td\u003e\n\u003ctd align=\"center\"\u003e1.570398\u003c/td\u003e\n\u003ctd align=\"center\"\u003e1.228455\u003c/td\u003e\n\u003ctd align=\"center\"\u003e1.254492\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e1000\u003c/td\u003e\n\u003ctd align=\"center\"\u003e49.56317\u003c/td\u003e\n\u003ctd align=\"center\"\u003e60.15104\u003c/td\u003e\n\u003ctd align=\"center\"\u003e60.15104\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e10,000\u003c/td\u003e\n\u003ctd align=\"center\"\u003e466.007770\u003c/td\u003e\n\u003ctd align=\"center\"\u003e663.163937\u003c/td\u003e\n\u003ctd align=\"center\"\u003e663.961094\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e100,000\u003c/td\u003e\n\u003ctd align=\"center\"\u003e6516.490799\u003c/td\u003e\n\u003ctd align=\"center\"\u003e7105.19345\u003c/td\u003e\n\u003ctd align=\"center\"\u003e7107.097945\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e结论：多订阅会有一定时间上的损耗，但损耗不大。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e//并发测试脚本\npackage main\n\nimport (\n\t\u0026quot;github.com/nsqio/go-nsq\u0026quot;\n\t\u0026quot;log\u0026quot;\n\t\u0026quot;runtime\u0026quot;\n\t\u0026quot;time\u0026quot;\n\t\u0026quot;sync\u0026quot;\n\t\u0026quot;flag\u0026quot;\n)\n\nvar (\n\tnum        = flag.Int(\u0026quot;num\u0026quot;, 1000, \u0026quot;number of profuced\u0026quot;)\n\ttcpAddress = flag.String(\u0026quot;nsqd-tcp-address\u0026quot;, \u0026quot;127.0.0.1:4150\u0026quot;, \u0026quot;\u0026lt;addr\u0026gt;:\u0026lt;port\u0026gt; to connect to nsqd\u0026quot;)\n)\n\nfunc main() {\n\tflag.Parse()\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\ttest := Tester{}\n\tgo func() {\n\t\ttest.Produce(*num)\n\t}()\n\n\ttime.Sleep(500 * time.Millisecond) //等待生产一定数量\n\ttest.Consume(*num,\u0026quot;ch\u0026quot;)\n}\n\ntype Tester struct {\n\n}\n//Produce 测试生产数据， num 生产条数\nfunc (this *Tester) Produce(num int) {\n\tconfig := nsq.NewConfig()\n\tw, _ := nsq.NewProducer(tcpAddress, config)\n\tstart := time.Now()\n\tfor i := 0; i \u0026lt; num; i++ {\n\t\terr := w.Publish(\u0026quot;mc_topic_test\u0026quot;, []byte(\u0026quot;t\u0026quot;))\n\t\tif err != nil {\n\t\t\tlog.Panicln(i, err)\n\t\t}\n\t}\n\telapsed := time.Since(start)\n\tlog.Printf(\u0026quot;生产 %d 条数据耗时 %f\u0026quot;, num, float64(elapsed.Nanoseconds()) / 1000000)\n\tw.Stop()\n}\n//Consume 测试消费 num 生产条数, channel 订阅的 channel\nfunc (this *Tester) Consume(num int, channel  string) {\n\twg := \u0026amp;sync.WaitGroup{}\n\twg.Add(1)\n\tconfig := nsq.NewConfig()\n\tq, _ := nsq.NewConsumer(\u0026quot;mc_topic_test\u0026quot;, channel, config)\n\tcnt := num\n\tstart := time.Now()\n\tq.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {\n\t\t//log.Printf(\u0026quot;Got a message: %v\u0026quot;, string(message.Body))\n\t\t//wg.Done()\n\t\tcnt --\n\t\tif cnt == 0 {\n\t\t\telapsed := time.Since(start)\n\t\t\tlog.Printf(\u0026quot;消费 %d 条数据耗时 %f\u0026quot;, num, float64(elapsed.Nanoseconds()) / 1000000)\n\t\t\twg.Done()\n\t\t}\n\t\treturn nil\n\t}))\n\terr := q.ConnectToNSQD(\u0026quot;127.0.0.1:4150\u0026quot;)\n\n\tif err != nil {\n\t\tlog.Panic(\u0026quot;无法连接\u0026quot;)\n\t}\n\twg.Wait()\n}\n\u003c/code\u003e\u003c/pre\u003e\n","location":"开发/nsq/NSQ入门指南","picture":"https://nanxi.li/开发/nsq/img/cover.png","tags":["MQ"],"title":"NSQ 快速入门和性能测试\n"}