{"date":"2017-05-02T00:00:00Z","html":"\u003cp\u003eCoAP是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。\u003c/p\u003e\n\n\u003cp\u003eCOAP 相当于 HTTP Restful 就比如， arm 相当于 x86\u003c/p\u003e\n\n\u003ch2 id=\"coap-应用层解释\"\u003eCOAP 应用层解释\u003c/h2\u003e\n\n\u003cp\u003ecoap请求代码示例\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ecoapClient, err := coap.Dial(\u0026quot;myhourse.local:5683\u0026quot;)\nreq := coap.Message{\n\t\tType:      coap.Confirmable,\n\t\tCode:      coap.POST,\n\t\tMessageID: 12345,\n\t\tPayload:   cbor.MustMarshal(People {\n\t\t\tName :\u0026quot;张三丰\u0026quot;,\n\t\t}),\n\t}\nreq.SetOption(coap.ContentFormat, coap.AppCBOR)\nreq.SetPathString(\u0026quot;/lock/3/users\u0026quot;)\nrv, err := coapClient.Send(req)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecoap://myhourse.local/lock/3/users\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eGET\u003c/code\u003e \u003ccode\u003ePOST\u003c/code\u003e \u003ccode\u003ePUT\u003c/code\u003e \u003ccode\u003eDELETE\u003c/code\u003e\u003c/p\u003e\n\n\u003ch3 id=\"简介\"\u003e简介\u003c/h3\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eCoAP协议基于REST 构架，REST 是指表述性状态转换架构，是互联网资源访问协议的一般性设计风格。为了克服HTTP对于受限环境的劣势，CoAP既考虑到数据报长度的最优化，又考虑到提供可靠通信。一方面，CoAP提供URI，REST 式的方法如GET，POST，PUT和DELETE，以及可以独立定义的头选项提供的可扩展性。另一方面，CoAP基于轻量级的UDP协议，并且允许IP多播。而组通信是物联网最重要的需求之一，比如说用于自动化应用中。为了弥补UDP传输的不可靠性，CoAP定义了带有重传机制的事务处理机制。并且提供资源发现机制，并带有资源描述。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eCoAP的特点\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eCoAP采用了二进制报头，而不是文本报头(text header)。\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003eCoAP降低了头的可用选项的数量。\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003eCoAP减少了一些HTTP的方法。\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003eCoAP可以支持检测装置。\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCoAP与Http协议\u003c/p\u003e\n\n\u003cp\u003eCoAP协议采用了双层的结构。事务层(Transaction layer)处理节点间的信息交换，同时，也提供对多播和拥塞控制的支持。请求/响应层(Request/Response layer)用以传输对资源进行操作的请求和相应信息。CoAP协议的REST 构架基于该层的通信，REST请求附在一个CON 或者NON消息上，而REST响应附在匹配的ACK消息上。\u003c/p\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/IoT/coap/coap_http.jpg\" alt=\"coap_http\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eCoAP的双层处理方式，使得CoAP没有采用TCP协议，也可以提供可靠的传输机制。利用默认的定时器和指数增长的重传间隔时间实现 CON消息的重传，直到接收方发出确认消息。另外，CoAP的双层处理方式支持异步通信，这是物联网和M2M应用的关键需求之一。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"报文详情\"\u003e报文详情\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-coap\"\u003e   0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |Ver| T |  TKL  |      Code     |          Message ID           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   Token (if any, TKL bytes) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   Options (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |1 1 1 1 1 1 1 1|    Payload (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"type\"\u003eType\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003e    Confirmable \t COAPType = 0 //需要响应，确认\n\tNonConfirmable   COAPType = 1 \n\tAcknowledgement  COAPType = 2 //确认\n\tReset COAPCode   COAPType = 3\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"请求类型-confirmable-nonconfirmable\"\u003e请求类型 Confirmable NonConfirmable\u003c/h4\u003e\n\n\u003cp\u003e0 Confirmable：需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。 （用于同步请求，控制指令等）\u003c/p\u003e\n\n\u003cp\u003e1 NonConfirmable：不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。（用于属性上报，日志记录等）\u003c/p\u003e\n\n\u003ch4 id=\"响应类型-acknowledgement-reset\"\u003e响应类型 Acknowledgement Reset\u003c/h4\u003e\n\n\u003cp\u003e2 Acknowledgement：应答消息，接受到Confirmable消息的响应。(ACK)\u003c/p\u003e\n\n\u003cp\u003e3 Reset 消息代表的是一个消息（需要应答或者不需要应答的消息）被收到了，但是由于缺少某些上下文信息而无法被正常的处理。这种情况通常是由于接收节点重启了，因而缺失了一些必要的信息，导致当前接收到的消息无法被处理。利用reset消息，也是一种低开销的检查端是否存活的方式（也称作CoAP ping，发送一个空的需应答消息）类似于http响应的：Provisional headers are shown\u003c/p\u003e\n\n\u003ch3 id=\"code\"\u003eCode\u003c/h3\u003e\n\n\u003ch4 id=\"请求方法码-method-code\"\u003e请求方法码（Method Code）\u003c/h4\u003e\n\n\u003cp\u003e类似于 HTTP的请求 METHOD，用于消息请求\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    GET    COAPCode = 1\n\tPOST   COAPCode = 2\n\tPUT    COAPCode = 3\n\tDELETE COAPCode = 4\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"响应码-response-code\"\u003e响应码（Response Code）\u003c/h4\u003e\n\n\u003cp\u003e用于消息等响应，类似于HTTP的200，400，404, 401 等\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\t// 2.x\n\tCoapCodeCreated  CoapCode = 65 // 2.01\n\tCoapCodeDeleted  CoapCode = 66 // 2.02\n\tCoapCodeValid    CoapCode = 67 // 2.03\n\tCoapCodeChanged  CoapCode = 68 // 2.04\n\tCoapCodeContent  CoapCode = 69 // 2.05\n\tCoapCodeContinue CoapCode = 95 // 2.31\n\n\t// 4.x\n\tCoapCodeBadRequest               CoapCode = 128 // 4.00\n\tCoapCodeUnauthorized             CoapCode = 129 // 4.01\n\tCoapCodeBadOption                CoapCode = 130 // 4.02\n\tCoapCodeForbidden                CoapCode = 131 // 4.03\n\tCoapCodeNotFound                 CoapCode = 132 // 4.04\n\tCoapCodeMethodNotAllowed         CoapCode = 133 // 4.05\n\tCoapCodeNotAcceptable            CoapCode = 134 // 4.06\n\tCoapCodeRequestEntityIncomplete  CoapCode = 136 // 4.08\n\tCoapCodeConflict                 CoapCode = 137 // 4.09\n\tCoapCodePreconditionFailed       CoapCode = 140 // 4.12\n\tCoapCodeRequestEntityTooLarge    CoapCode = 141 // 4.13\n\tCoapCodeUnsupportedContentFormat CoapCode = 143 // 4.15\n\n\t// 5.x\n\tCoapCodeInternalServerError  CoapCode = 160 // 5.00\n\tCoapCodeNotImplemented       CoapCode = 161 // 5.01\n\tCoapCodeBadGateway           CoapCode = 162 // 5.02\n\tCoapCodeServiceUnavailable   CoapCode = 163 // 5.03\n\tCoapCodeGatewayTimeout       CoapCode = 164 // 5.04\n\tCoapCodeProxyingNotSupported CoapCode = 165 // 5.05\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"token\"\u003eToken\u003c/h3\u003e\n\n\u003cp\u003e令牌（token） token是用于匹配响应与请求的。token的值有0~8字节（注意，每个信息都携带token，即使其长度为零）。每个请求都携带由客户端生成的token，服务端在响应时必须复制（不能修改）这个token。\u003c/p\u003e\n\n\u003cp\u003etoken用作client-local标示，用于区分并发请求，也称为“request ID”。\u003c/p\u003e\n\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003e   +-----+---+---+---+---+----------------+--------+--------+----------+\n   | No. | C | U | N | R | Name           | Format | Length | Default  |\n   +-----+---+---+---+---+----------------+--------+--------+----------+\n   |   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |\n   |   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |\n   |     |   |   |   |   |                |        |        | below)   |\n   |   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |\n   |   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |\n   |   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |\n   |     |   |   |   |   |                |        |        | below)   |\n   |   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |\n   |  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |\n   |  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |\n   |  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |\n   |  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |\n   |  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |\n   |  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |\n   |  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |\n   |  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |\n   |  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |\n   +-----+---+---+---+---+----------------+--------+--------+----------+\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003e\tIfMatch       OptionID = 1\n\tURIHost       OptionID = 3\n\tETag          OptionID = 4\n\tIfNoneMatch   OptionID = 5\n\tObserve       OptionID = 6\n\tURIPort       OptionID = 7\n\tLocationPath  OptionID = 8\n\tURIPath       OptionID = 11\n\tContentFormat OptionID = 12\n\tMaxAge        OptionID = 14\n\tURIQuery      OptionID = 15\n\tAccept        OptionID = 17\n\tLocationQuery OptionID = 20\n\tProxyURI      OptionID = 35\n\tProxyScheme   OptionID = 39\n\tSize1         OptionID = 60\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e保留定义：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e       +-------------+---------------------------------------+\n          |       Range | Registration Procedures               |\n          +-------------+---------------------------------------+\n          |       0-255 | IETF Review or IESG Approval          |\n          |    256-2047 | Specification Required                |\n          |  2048-64999 | Expert Review                         |\n          | 65000-65535 | Experimental use (no operational use) |\n          +-------------+---------------------------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e添加Token验证请求， 可用于鉴权 (ietf草稿文档)\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e   +-----+---+---+---+---+----------------------+--------+--------+------------------ ----+\n   | No. | C | U | N | R | Name                 | Format | Length | Default               |\n   +-----+---+---+---+---+----------------------+--------+--------+-----------------------+\n   |  64 |   |   |   |   | Authorization        | opaque | 1-1034 | (none)                |\n   |  65 | x |   |   |   | Authorization-Format | uint   | 0-2    | application/cose+cbor |\n   +-----+---+---+---+---+--------------- ------+--------+--------+-----------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eapplication/cose+cbor 可以理解为二进制的json编码格式，比Json更小，但是大部分情况下， Authorization-Format这个值可以写0，即  text/plain;charset=utf-8 格式。\u003c/p\u003e\n\n\u003ch4 id=\"uri-host-uri-port-uri-path-and-uri-query\"\u003eUri-Host, Uri-Port, Uri-Path, and Uri-Query\u003c/h4\u003e\n\n\u003cp\u003e例如接口如下：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eGET coap://dc.spotmau.cn:5683/lock/v3/home/2435/users?name=张三丰\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e查询HOME ID 是 2435 的家庭中，姓名为张三丰的用户的详情。\u003c/p\u003e\n\n\u003cp\u003e对应的参数为:\u003c/p\u003e\n\n\u003cp\u003eUri-Host: dc.spotmau.cn\nUri-Port: 5683\nUri-Path: lock/v3/users/dn6426523\nUri-Query: name=张三丰\u003c/p\u003e\n\n\u003ch4 id=\"if-match\"\u003eIf-Match\u003c/h4\u003e\n\n\u003cp\u003e字面意思：如果目标数据的ETag和 if-match数值相同，则做某事。用于保护多个客户端在同一资源下进行类似操作时意外覆盖（比如“lost update”问题）。\u003c/p\u003e\n\n\u003cp\u003e例如：多个客户端同时请求修改门锁数据时，添加 if-match aaaaa, 则表示，只有门锁数据的etag为aaaaa的时候才修改，否则忽略。\u003c/p\u003e\n\n\u003ch4 id=\"etag\"\u003eETag\u003c/h4\u003e\n\n\u003cp\u003e资源唯一标识符，用户检测变化。md5, time 等混合。（一般服务器端使用）\u003c/p\u003e\n\n\u003ch4 id=\"if-none-match\"\u003eIf-None-Match\u003c/h4\u003e\n\n\u003cp\u003e字面意思：如果目标数据不存在时，则做某事。否则忽略。\u003c/p\u003e\n\n\u003ch4 id=\"observe\"\u003eObserve\u003c/h4\u003e\n\n\u003cp\u003e用于消息订阅/发布模式，详见：观察者机制代码实现\u003c/p\u003e\n\n\u003ch4 id=\"location-path和-location-query\"\u003eLocation-Path和 Location-Query\u003c/h4\u003e\n\n\u003cp\u003eLocation-Path和Location-Query选项定义由一个绝对路径、一个请求字符串，或者二者一起组成的相对URI。\u003c/p\u003e\n\n\u003ch4 id=\"content-format\"\u003eContent-Format\u003c/h4\u003e\n\n\u003cpre\u003e\u003ccode\u003e\tTextPlain     MediaType = 0  // text/plain;charset=utf-8\n\tAppLinkFormat MediaType = 40 // application/link-format\n\tAppXML        MediaType = 41 // application/xml\n\tAppOctets     MediaType = 42 // application/octet-stream\n\tAppExi        MediaType = 47 // application/exi\n\tAppJSON       MediaType = 50 // application/json\n\tAppCBOR       MediaType = 60 // application/json\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"max-age\"\u003eMax-Age\u003c/h4\u003e\n\n\u003cp\u003eMax-Age 定义最大缓存实践， 最多能缓存的时间， 一般为GET到的内容的有效期。\u003c/p\u003e\n\n\u003cp\u003e该选项的值是一个整型的秒数，从0到2**32-1（大约136.1年）。如响应中没有定义这个选项，它的默认值是60秒。\u003c/p\u003e\n\n\u003ch4 id=\"accept\"\u003eAccept\u003c/h4\u003e\n\n\u003cp\u003e类似于 http的Accept，客户端接受服务端返回它指定的格式。如果服务端无法提供客户端指定的格式，服务端必须返回一个4.06“Not Acceptable”，\u003c/p\u003e\n\n\u003ch4 id=\"proxy-uri和proxy-scheme\"\u003eProxy-Uri和Proxy-Scheme\u003c/h4\u003e\n\n\u003cp\u003e和 http的 类似\u003c/p\u003e\n\n\u003ch4 id=\"size1\"\u003eSize1\u003c/h4\u003e\n\n\u003cp\u003e用于限制请求字节数， 如果一个请求返回413 （Request Entity Too Large）， 则该请求所有响应会包含Size1字段。\u003c/p\u003e\n\n\u003ch2 id=\"coap-订阅机制代码实现\"\u003eCOAP 订阅机制代码实现\u003c/h2\u003e\n\n\u003cp\u003e观察者模式又称发布订阅模式\u003c/p\u003e\n\n\u003cp\u003e代码演示：\u003c/p\u003e\n\n\u003cp\u003eServer\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc periodicTransmitter(l *net.UDPConn, a *net.UDPAddr, m *coap.Message) {\n\tsubded := time.Now()\n\tfor {\n\t\tmsg := coap.Message{\n\t\t\tType:      coap.Acknowledgement,\n\t\t\tCode:      coap.Content,\n\t\t\tMessageID: m.MessageID,\n\t\t\tPayload:   []byte(fmt.Sprintf(\u0026quot;Been running for %v\u0026quot;, time.Since(subded))),\n\t\t}\n\n\t\tmsg.SetOption(coap.ContentFormat, coap.TextPlain)\n\t\tlog.Println(m.Path())\n\t\tmsg.SetOption(coap.LocationPath, m.Path())\n\n\t\tlog.Printf(\u0026quot;Transmitting %v\u0026quot;, msg)\n\t\terr := coap.Transmit(l, a, msg)\n\t\tif err != nil {\n\t\t\tlog.Printf(\u0026quot;Error on transmitter, stopping: %v\u0026quot;, err)\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tcoap.ListenAndServe(\u0026quot;udp\u0026quot;, \u0026quot;:5683\u0026quot;, coap.FuncHandler(func(l *net.UDPConn, a *net.UDPAddr, m *coap.Message) *coap.Message {\n\t\t\tif m.Code == coap.GET \u0026amp;\u0026amp; m.Option(coap.Observe) != nil {\n\t\t\t\t//判断如果是Observe类型，则调用订阅事件\n\t\t\t\tif value, ok := m.Option(coap.Observe).(uint32); ok \u0026amp;\u0026amp; value == 1 \u0026amp;\u0026amp; m.Path()[0]== \u0026quot;obs\u0026quot;  {\n\t\t\t\t\tgo periodicTransmitter(l, a, m)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}))\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eClient\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ereq := coap.Message{\n\t\tType:      coap.NonConfirmable,\n\t\tCode:      coap.GET,\n\t\tMessageID: 12345,\n\t}\n\treq.AddOption(coap.Observe, 1)\n\treq.SetPathString(\u0026quot;/obs\u0026quot;)\n\n\tc, err := coap.Dial(\u0026quot;udp\u0026quot;, \u0026quot;localhost:5683\u0026quot;)\n\tif err != nil {\n\t\tlog.Fatalf(\u0026quot;Error dialing: %v\u0026quot;, err)\n\t}\n\n\trv, err := c.Send(req)\n\tif err != nil {\n\t\tlog.Fatalf(\u0026quot;Error sending request: %v\u0026quot;, err)\n\t}\n\tfor err == nil {\n\t\tif rv != nil {\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\u0026quot;Error receiving: %v\u0026quot;, err)\n\t\t\t}\n\t\t\tlog.Printf(\u0026quot;Got %s\u0026quot;, rv.Payload)\n\t\t}\n\t\trv, err = c.Receive()\n\n\t}\n   log.Printf(\u0026quot;Done...\\n\u0026quot;, err)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e从代码分析可看出，发布订阅模式其实是对指定path的轮询Receive，与http轮询不同的是，发送一次请求，没有握手机制。可以设置重试次数。\u003c/p\u003e\n\n\u003ch2 id=\"coap-多播模式实现\"\u003eCOAP 多播模式实现\u003c/h2\u003e\n\n\u003cp\u003eCoAP支持在IP多播组中发送请求，这相当于连续的单播CoAP。使用场景类似于我们的APP消息推送，这种场景只推送消息，不需要接受消息应答。\u003c/p\u003e\n\n\u003ch3 id=\"消息层\"\u003e消息层\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e多播请求的特点是目的地址由具体的CoAP端地址变成了IP多播地址，多播请求必须是不需应答消息。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"请求响应层\"\u003e请求响应层\u003c/h3\u003e\n\n\u003cp\u003e如果服务端决定响应一个多播请求，它不应该立即响应。相反它应该会等待一段时间才进行响应。我们把这段时间称为空闲（Leisure）时间。\u003c/p\u003e\n\n\u003ch2 id=\"coap-服务器api最佳实践\"\u003eCOAP 服务器API最佳实践\u003c/h2\u003e\n\n\u003ch4 id=\"api-文档示例-设备向服务器端请求\"\u003eAPI 文档示例:  设备向服务器端请求\u003c/h4\u003e\n\n\u003cp\u003e向某个家庭添加用户\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePOST coaps://dc.spotmau.cn:5683/lock/v3/home/:id/users\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"请求参数\"\u003e请求参数\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode\u003eContent-Type: application/json\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e参数\u003c/th\u003e\n\u003cth align=\"center\"\u003e类型\u003c/th\u003e\n\u003cth align=\"center\"\u003e是否必须\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003ename\u003c/td\u003e\n\u003ctd align=\"center\"\u003estring\u003c/td\u003e\n\u003ctd align=\"center\"\u003e是\u003c/td\u003e\n\u003ctd\u003e人员姓名：长度：2～16\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003eimage\u003c/td\u003e\n\u003ctd align=\"center\"\u003estring\u003c/td\u003e\n\u003ctd align=\"center\"\u003e否\u003c/td\u003e\n\u003ctd\u003e人员头像的base64编码\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003edesc\u003c/td\u003e\n\u003ctd align=\"center\"\u003estring\u003c/td\u003e\n\u003ctd align=\"center\"\u003e否\u003c/td\u003e\n\u003ctd\u003e人员描述\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch5 id=\"响应\"\u003e响应\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode\u003eCode: 0 OK\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003eCode:  != 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e状态码\u003c/th\u003e\n\u003cth\u003e错误类型\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e4.00\u003c/td\u003e\n\u003ctd\u003einvalid_home\u003c/td\u003e\n\u003ctd\u003e未找到对应家庭\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e4.00\u003c/td\u003e\n\u003ctd\u003einvalid_phone\u003c/td\u003e\n\u003ctd\u003e被授权用户未绑定手机\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e5.00\u003c/td\u003e\n\u003ctd\u003einternal_server_error\u003c/td\u003e\n\u003ctd\u003e系统处理错误\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e4.09\u003c/td\u003e\n\u003ctd\u003econflict\u003c/td\u003e\n\u003ctd\u003e创建家庭数量超过限制\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026quot;error\u0026quot;: \u0026quot;invalid_home\u0026quot;,\n  \u0026quot;error_description\u0026quot;: \u0026quot;home not found\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCoAP-HTTP Proxying\u003c/p\u003e\n\n\u003cp\u003eHTTP-CoAP Proxying\u003c/p\u003e\n\n\u003ch4 id=\"api-文档示例-服务器向设备请求\"\u003eAPI 文档示例:  服务器向设备请求\u003c/h4\u003e\n\n\u003cp\u003e代理模式\u003c/p\u003e\n\n\u003cp\u003e添加用户\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePOST coaps://[2001:db8::2:1]:5683/device_id/lock/:id/people\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026quot;name\u0026quot;:\u0026quot;张三丰\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e删除用户\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eDELETE coaps://[2001:db8::2:1]:5683/device_id/lock/:id/people/:uid\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e修改用户\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePUT coaps://[2001:db8::2:1]:5683/device_id/lock/:id/people/:uid\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026quot;name\u0026quot;:\u0026quot;张三\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e查询用户\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eGET coaps://[2001:db8::2:1]:5683/device_id/lock/:id/people?name=\u0026quot;张三\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003eGET coaps://[2001:db8::2:1]:5683/device_id/open\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"请求参数-1\"\u003e请求参数\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode\u003eAuthorization: {{wang_guan_token}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"响应-1\"\u003e响应\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode\u003eCode: 2.x OK\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003eCode:  != 2.x\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"center\"\u003e状态码\u003c/th\u003e\n\u003cth\u003e错误类型\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e4.04\u003c/td\u003e\n\u003ctd\u003enot_found\u003c/td\u003e\n\u003ctd\u003e设备不存在\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e4.01\u003c/td\u003e\n\u003ctd\u003eunauthorized\u003c/td\u003e\n\u003ctd\u003e没有添加验证\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e4.03\u003c/td\u003e\n\u003ctd\u003eforbidden\u003c/td\u003e\n\u003ctd\u003e操作被拒绝\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd align=\"center\"\u003e5.00\u003c/td\u003e\n\u003ctd\u003einternal_server_error\u003c/td\u003e\n\u003ctd\u003e处理错误，会将错误信息返回到结果Body\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2 id=\"coaps-加密传输\"\u003eCOAPs 加密传输\u003c/h2\u003e\n\n\u003cp\u003eCOAP 采用 DTLS作为加密手段， PSK 是DTLS 定义的密钥交换方案之一，相对于公钥证书方案(如 ECDHA_RSA) 来说，其具备更加轻量化、高效的优点。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e//服务器端\nserver.HandlePSK(func(id string) []byte {\n\t\treturn []byte(\u0026quot;secretPSK\u0026quot;)\n\t})\nserver.ListenAndServeDTLS(\u0026quot;:5684\u0026quot;)\n\n//客户端\nconn, err := coap.DialDTLS(\u0026quot;localhost:5684\u0026quot;, \u0026quot;clientId\u0026quot;, \u0026quot;secretPSK\u0026quot;)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\n\u003cp\u003e从代码实现可以看出CoAP 是类似于 HTTP Restful API形式， 请求和返回消息格式一致，集成设备订阅模式的物联网解决方案。CoAP可以作为短连和长连处理，支持重连机制的无序消息解决方案。\u003c/p\u003e\n\n\u003cp\u003eCoAP相对于MqTT而言，有以下不同：\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eCoAP 允许将设备作为服务器终端，允许在没有长连的情况下向设备发送指令。\u003c/li\u003e\n\u003cli\u003eMqTT 的思想是将设备集中联网，然后采取订阅发送的模式。\u003c/li\u003e\n\u003cli\u003eCoAP 的订阅模式不能获取消息的应答。\u003c/li\u003e\n\u003cli\u003e模式使用场景：以开门为例：开门，则向设备发送 GET coap://cip:cport/lock_id/unlock 方法， 关门则发送  coap://cip:cport/lock_id/lock 方法。消息推送则采取订阅方式。\u003c/li\u003e\n\u003cli\u003eCoAP 默认采用PSK算法保证数据传输加密。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"请求-响应的匹配\"\u003e请求/响应的匹配\u003c/h2\u003e\n\n\u003cp\u003e见于目前请求响应模型和当前系统差别很大，就请求/响应的匹配做补充说明。\u003c/p\u003e\n\n\u003ch3 id=\"5-3-1-令牌-token\"\u003e5.3.1, 令牌（token）\u003c/h3\u003e\n\n\u003cp\u003etoken是用于匹配响应与请求的。token的值有0~8字节（注意，每个信息都携带token，即使其长度为零）。每个请求都携带由客户端生成的token，服务端在响应时必须复制（不能修改）这个token。\u003c/p\u003e\n\n\u003cp\u003etoken用作client-local标示，用于区分并发请求（参见5.3节），也称为“request ID”。\u003c/p\u003e\n\n\u003cp\u003e客户端生成token时需要注意，当前使用的token对给定的源端和目的端应该都是独一无二的。（注意客户端在生成token时，如果要向不同的端（比如源端口号不同）中发送请求，可以使用同样的token）。当只向目的端产生一个token，或者向每个目的端发送的请求都是顺序的，且都是附带响应，token为空也是可行的。有多种策略实现。\u003c/p\u003e\n\n\u003cp\u003e如果客户端不使用传输层安全(TLS，见第9章）发送请求，就需要使用复杂的，随机的token来防止欺诈响应（见11.4节），起到保护功能，这也是token允许使用最多8个字节的原因。token中随机组件的实际长度取决于客户端的安全需求和欺诈响应造成的威胁程度。接入到互联网的客户端至少应该使用32位随机码，记住，没有直接连接互联网也不一定能有效防范欺诈。注意，Message ID几乎没有添加保护，因为它通常是顺序分配的，因此可能被猜测到，并通过欺诈响应绕过。客户端想要优化token长度，可能会向进一步检测正在进行的攻击等级（例如计算接收的token不匹配的消息个数）。[RFC4086]讨论对安全的随机性要求。\u003c/p\u003e\n\n\u003cp\u003e端接收一个不是它生成的token，必须把这个token当做不透明的，不能假设它的内容和结构。\u003c/p\u003e\n\n\u003ch3 id=\"5-3-2-请求-响应匹配规则\"\u003e5.3.2, 请求/响应匹配规则\u003c/h3\u003e\n\n\u003cp\u003e确切的匹配响应与请求的规则如下：\u003c/p\u003e\n\n\u003cp\u003e响应的源端必须和原始请求的目的端一致。\u003c/p\u003e\n\n\u003cp\u003e在附带响应中，CON请求和ACK的“Message ID”必须匹配，响应和原始请求的“token”必须匹配。在单独响应中，只需响应和原始请求的“token”匹配。万一信息携带异常的响应（不是认定的端，端地址、token和客户端的期望不匹配），这个响应必须被拒绝（见4.2和4.3）。\u003c/p\u003e\n\n\u003cp\u003e注意：客户端接收到CON响应之后，可能想在回复完ACK马上清除这个消息的状态。如果这个ACK丢失，且服务端重传这个CON消息，客户端可能不会再有任何与该响应相关联的状态，会导致这个重传成为异常消息；客户端可能会发送RST信息，这样它就不会再收到更多的重传消息。这个行为是正常的，并不是一个错误（没有积极优化内存使用状态的客户端会将第二个CON认定为重发。客户端事实上期望从服务器[observe]得到更多消息，就必须在任何情况下保持状态）。\u003c/p\u003e\n","location":"开发/IoT/coap/COAP 应用详解","picture":"https://nanxi.li/开发/IoT/coap/iot.png","tags":["MQ"],"title":"COAP 应用详解\n"}