{"date":"2025-09-26T00:00:00Z","html":"\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\n\n\u003cp\u003e在现代机器人开发领域，传统的开发模式往往依赖于真实硬件设备进行数据采集和算法验证，这种方式不仅成本高昂，而且存在设备损坏风险、环境限制等诸多挑战。随着云计算技术的快速发展，基于云端的机器人仿真平台为开发者提供了全新的解决方案。\u003c/p\u003e\n\n\u003cp\u003e本文将详细介绍如何利用AWS云计算平台的强大计算能力，结合NVIDIA Isaac Sim仿真环境，实现Lerobot SO-101机械臂的远程遥操作和数据收集。这种云端仿真方案不仅能够显著降低硬件成本，还能提供可扩展的计算资源，支持大规模并行仿真实验，为机器人算法的快速迭代和验证提供理想的开发环境。\u003c/p\u003e\n\n\u003ch2 id=\"架构设计\"\u003e架构设计\u003c/h2\u003e\n\n\u003ch3 id=\"流程图\"\u003e流程图\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003egraph TB\n    subgraph \u0026quot;本地环境\u0026quot;\n        A[本地Lerobot SO-101设备]\n        B[ROS2数据采集节点]\n        C[开发者工作站]\n        D[Amazon DCV 客户端]\n    end\n\n    subgraph \u0026quot;AWS EC2 Isaac Sim 工作站\u0026quot;\n        G[Amazon DCV Server]\n        H[NVIDIA Isaac Sim仿真引擎]\n        I[rosbridge-suite服务]\n        K[数据收集模块]\n        L[Amazon S3存储]\n    end\n    \n    %% 数据流入口1：rosbridge WebSocket\n    A --\u0026gt; B\n    B --\u0026gt; |WebSocket|I\n    I --\u0026gt; |ROS2桥接|H\n    H --\u0026gt; |仿真反馈|I\n    \n    %% 数据流入口2：Amazon DCV可视化\n    C --\u0026gt; D\n    D --\u0026gt; |远程桌面|G\n    G --\u0026gt; H\n    \n    %% 数据存储流\n    H --\u0026gt; K\n    K --\u0026gt; L\n    \n    %% 样式定义\n    classDef localEnv fill:#e1f5fe\n    classDef awsService fill:#fff3e0\n    classDef dataFlow fill:#f3e5f5\n    \n    class A,B,C localEnv\n    class F,G,H,I,J,K,L awsService\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"架构概述\"\u003e架构概述\u003c/h3\u003e\n\n\u003cp\u003e该架构通过AWS EC2构建云端Isaac Sim仿真环境，实现本地机器人设备与云端仿真的无缝集成，支持远程开发和数据收集。\u003c/p\u003e\n\n\u003ch4 id=\"核心组件\"\u003e核心组件\u003c/h4\u003e\n\n\u003cp\u003e本地环境\n• Lerobot SO-101设备作为物理机器人平台\n• ROS2数据采集节点负责传感器数据收集\n• 开发者工作站提供开发界面\n• Amazon DCV客户端实现远程可视化访问\u003c/p\u003e\n\n\u003cp\u003eAWS云端环境\n• EC2实例运行NVIDIA Isaac Sim仿真引擎\n• Amazon DCV Server提供高性能远程桌面服务\n• rosbridge-suite实现ROS2与本地设备的通信\n• S3存储服务保存仿真数据和模型\u003c/p\u003e\n\n\u003ch4 id=\"数据流程\"\u003e数据流程\u003c/h4\u003e\n\n\u003cp\u003e实时数据同步\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e本地SO-101设备通过ROS2节点采集传感器数据\u003c/li\u003e\n\u003cli\u003e数据经WebSocket协议传输至云端rosbridge服务\u003c/li\u003e\n\u003cli\u003erosbridge将数据桥接到Isaac Sim仿真环境\u003c/li\u003e\n\u003cli\u003e仿真引擎处理后返回反馈数据到本地设备\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e远程开发访问\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e开发者通过DCV客户端连接云端工作站\u003c/li\u003e\n\u003cli\u003e获得Isaac Sim的完整图形界面访问权限\u003c/li\u003e\n\u003cli\u003e实时调试和配置仿真参数\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e数据持久化\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e仿真过程中的训练数据、模型参数自动收集\u003c/li\u003e\n\u003cli\u003e通过数据收集模块统一管理\u003c/li\u003e\n\u003cli\u003e存储至S3实现数据收集\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"实施方案\"\u003e实施方案\u003c/h3\u003e\n\n\u003ch4 id=\"阶段一-aws云端基础设施部署\"\u003e阶段一：AWS云端基础设施部署\u003c/h4\u003e\n\n\u003ch5 id=\"1-1-nvidia-isaac-sim-开发工作站部署\"\u003e1.1 NVIDIA Isaac Sim™开发工作站部署\u003c/h5\u003e\n\n\u003cp\u003e访问AWS Marketplace：\u003ca href=\"https://aws.amazon.com/marketplace/pp/prodview-bl35herdyozhw\"\u003ehttps://aws.amazon.com/marketplace/pp/prodview-bl35herdyozhw\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e部署路径：AWS控制台 → EC2 → 启动实例 → 浏览其他AMI → AWS Marketplace AMI → 搜索\u0026rdquo;NVIDIA Isaac Sim\u0026rdquo;\u003c/p\u003e\n\n\u003cp\u003e选择\u0026rdquo;NVIDIA Isaac Sim™ Development Workstation (Linux)\u0026ldquo;，配置网络安全组后启动实例。\u003c/p\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"/开发/isaac/aws-ros2-isaac-sim-blog.assets/image-20250925090831651.png\" alt=\"AMI\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e推荐配置规格\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e实例类型：\u003ccode\u003eg6e.8xlarge\u003c/code\u003e（GPU加速计算优化）\u003c/li\u003e\n\u003cli\u003e存储容量：\u003ccode\u003e500GB EBS gp3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e安全组规则：开放端口22（SSH）、8443（DCV远程桌面）、9090（WebSocket通信）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"阶段二-ros2数据采集环境配置与rosbridge服务部署\"\u003e阶段二：ROS2数据采集环境配置与Rosbridge服务部署\u003c/h4\u003e\n\n\u003ch5 id=\"2-1-本地开发环境初始化\"\u003e2.1 本地开发环境初始化\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 创建Lerobot专用Python环境\nconda create -y -n lerobot python=3.11\nconda activate lerobot\nconda install ffmpeg -c conda-forge\npip install 'lerobot[all]'\n\n# 配置ROS2 Jazzy发行版\nconda config --add channels conda-forge\nconda config --add channels robostack-jazzy\nconda config --set channel_priority strict\nconda install ros-jazzy-desktop -c robostack-jazzy\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"2-2-aws实例rosbridge服务配置\"\u003e2.2 AWS实例Rosbridge服务配置\u003c/h5\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 建立SSH安全连接\nssh -i your-key.pem ubuntu@\u0026lt;ec2_instance_ip\u0026gt;\n\n# 配置DCV远程访问凭据\nsudo passwd ubuntu\n\n# 部署ROS2 Jazzy发行版\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\necho \u0026quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release \u0026amp;\u0026amp; echo $UBUNTU_CODENAME) main\u0026quot; | sudo tee /etc/apt/sources.list.d/ros2.list \u0026gt; /dev/null\nsudo apt update \u0026amp;\u0026amp; sudo apt install -y ros-jazzy-desktop ros-dev-tools\nsource /opt/ros/jazzy/setup.bash\necho \u0026quot;source /opt/ros/jazzy/setup.bash\u0026quot; \u0026gt;\u0026gt; ~/.bashrc\n\n# 部署并启动Rosbridge WebSocket服务\nsudo apt install ros-jazzy-rosbridge-suite ros-jazzy-rosbridge-server ros-jazzy-topic-tools\nnohup ros2 launch rosbridge_server rosbridge_websocket_launch.xml port:=9090 2\u0026gt;\u0026amp;1 \u0026amp;\n\n# 验证服务运行状态\nlsof -i :9090\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"2-3-本地机器人设备接入配置\"\u003e2.3 本地机器人设备接入配置\u003c/h5\u003e\n\n\u003cp\u003e在本地开发环境中连接Lerobot SO-101机械臂：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 激活Lerobot运行环境\nconda activate lerobot\n\n# 自动检测机器人USB通信端口\npython -m lerobot.find_port\n\n# 启动本地遥操作模式（可选验证步骤）\npython -m lerobot.teleoperate \\\n    --robot.type=so101_follower \\\n    --robot.port=/dev/tty.usbmodem234561 \\\n    --robot.id=R12345 \\\n    --teleop.type=so101_leader \\\n    --teleop.port=/dev/tty.usbmodem123456 \\\n    --teleop.id=R12345\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch5 id=\"2-4-ros2通信桥接服务建立\"\u003e2.4 ROS2通信桥接服务建立\u003c/h5\u003e\n\n\u003cp\u003e部署本地USB数据到云端ROS2 Topic的桥接服务：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 本地控制节点实现 (lerobot_so101_ros2_bridge_remote.py)\n# 本地控制节点 (lerobot_so101_ros2_bridge_remote.py)\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\nimport websocket\nimport json\nimport serial\nimport time\nimport struct\nimport argparse\nimport sys\n\nclass JointStateReader2Remote(Node):\n    def __init__(self, usb_port, rosbridge_ws, device_id=\u0026quot;\u0026quot;):\n        super().__init__('joint_state_reader2remote')\n\n        self.usb_port = usb_port\n        self.rosbridge_ws = rosbridge_ws\n        self.device_id = device_id\n\n        # Configure topic names\n        prefix = f\u0026quot;/{device_id}\u0026quot; if device_id else \u0026quot;\u0026quot;\n        self.joint_states_topic = f\u0026quot;{prefix}/joint_states\u0026quot;\n        self.cmd_pose_topic = f\u0026quot;{prefix}/robot/cmd_pose\u0026quot;\n\n        # SO100 joint configuration\n        self.joint_names = ['shoulder_pan', 'shoulder_lift', 'elbow_flex', 'wrist_flex', 'wrist_roll', 'gripper']\n\n        # Initialize connections\n        self.serial_port = None\n        self.ws = None\n        self.connect_to_robot()\n        self.connect_to_websocket()\n\n        # State tracking\n        self.last_positions = [0.0] * len(self.joint_names)\n        self.read_errors = [0] * len(self.joint_names)\n        self.total_reads = 0\n        self.consecutive_errors = 0\n\n        # Start reading timer (20Hz)\n        self.timer = self.create_timer(0.05, self.read_and_publish)\n\n        self.get_logger().info(\u0026quot;SO100 Bridge started\u0026quot;)\n        self.get_logger().info(f\u0026quot;USB: {self.usb_port}\u0026quot;)\n        self.get_logger().info(f\u0026quot;WebSocket: {self.rosbridge_ws}\u0026quot;)\n        self.get_logger().info(f\u0026quot;Topics: {self.joint_states_topic}, {self.cmd_pose_topic}\u0026quot;)\n\n    def connect_to_robot(self):\n        \u0026quot;\u0026quot;\u0026quot;Connect to SO100 robot via USB\u0026quot;\u0026quot;\u0026quot;\n        try:\n            self.serial_port = serial.Serial(self.usb_port, 1000000, timeout=0.1)\n            self.serial_port.reset_input_buffer()\n            self.serial_port.reset_output_buffer()\n            time.sleep(0.1)\n            self.get_logger().info(\u0026quot;Connected to SO100 robot\u0026quot;)\n        except Exception as e:\n            self.get_logger().error(f\u0026quot;Failed to connect to robot: {e}\u0026quot;)\n            self.serial_port = None\n\n    def connect_to_websocket(self):\n        \u0026quot;\u0026quot;\u0026quot;Connect to remote WebSocket bridge\u0026quot;\u0026quot;\u0026quot;\n        try:\n            self.ws = websocket.WebSocket()\n            self.ws.connect(self.rosbridge_ws)\n\n            # Advertise topics\n            topics = [\n                (self.joint_states_topic, \u0026quot;sensor_msgs/JointState\u0026quot;),\n                (self.cmd_pose_topic, \u0026quot;geometry_msgs/Twist\u0026quot;)\n            ]\n\n            for topic, msg_type in topics:\n                advertise_msg = {\u0026quot;op\u0026quot;: \u0026quot;advertise\u0026quot;, \u0026quot;topic\u0026quot;: topic, \u0026quot;type\u0026quot;: msg_type}\n                self.ws.send(json.dumps(advertise_msg))\n\n            self.get_logger().info(\u0026quot;Connected to WebSocket bridge\u0026quot;)\n        except Exception as e:\n            self.get_logger().error(f\u0026quot;Failed to connect to WebSocket: {e}\u0026quot;)\n            self.ws = None\n\n    def read_servo_position(self, servo_id):\n        \u0026quot;\u0026quot;\u0026quot;Read position from STS3215 servo\u0026quot;\u0026quot;\u0026quot;\n        if not self.serial_port:\n            return None\n\n        try:\n            # Build command packet\n            length = 4\n            instruction = 0x02\n            address = 0x38\n            read_length = 0x02\n            checksum = (~(servo_id + length + instruction + address + read_length)) \u0026amp; 0xFF\n            cmd = bytes([0xFF, 0xFF, servo_id, length, instruction, address, read_length, checksum])\n\n            # Send command and read response\n            self.serial_port.reset_input_buffer()\n            self.serial_port.write(cmd)\n            time.sleep(0.002)\n            response = self.serial_port.read(8)\n\n            # Parse response\n            if len(response) \u0026gt;= 7 and response[0] == 0xFF and response[1] == 0xFF and response[2] == servo_id:\n                pos = struct.unpack('\u0026lt;H', response[5:7])[0]\n                if 0 \u0026lt;= pos \u0026lt;= 4095:\n                    return pos\n            return None\n\n        except Exception:\n            self.read_errors[servo_id - 1] += 1\n            return None\n\n    def ticks_to_radians(self, ticks, joint_idx):\n        \u0026quot;\u0026quot;\u0026quot;Convert servo ticks to radians\u0026quot;\u0026quot;\u0026quot;\n        if ticks is None:\n            return self.last_positions[joint_idx]\n        normalized = (ticks - 2048) / 2048.0\n        return normalized * 3.14159\n\n    def send_to_websocket(self, topic, msg_data):\n        \u0026quot;\u0026quot;\u0026quot;Send message to WebSocket\u0026quot;\u0026quot;\u0026quot;\n        if not self.ws:\n            return\n\n        try:\n            data = {\u0026quot;op\u0026quot;: \u0026quot;publish\u0026quot;, \u0026quot;topic\u0026quot;: topic, \u0026quot;msg\u0026quot;: msg_data}\n            self.ws.send(json.dumps(data))\n        except Exception as e:\n            self.get_logger().error(f\u0026quot;WebSocket send error: {e}\u0026quot;)\n            self.ws = None\n\n    def read_and_publish(self):\n        \u0026quot;\u0026quot;\u0026quot;Main loop: read joint positions and publish to WebSocket\u0026quot;\u0026quot;\u0026quot;\n        # Reconnect if needed\n        if not self.serial_port:\n            self.connect_to_robot()\n            return\n        if not self.ws:\n            self.connect_to_websocket()\n            return\n\n        self.total_reads += 1\n\n        # Read all joint positions\n        positions = []\n        successful_reads = 0\n\n        for i in range(len(self.joint_names)):\n            ticks = self.read_servo_position(i + 1)\n            radians = self.ticks_to_radians(ticks, i)\n            positions.append(radians)\n\n            if ticks is not None:\n                successful_reads += 1\n            time.sleep(0.01)\n\n        # Handle connection errors\n        if successful_reads == 0:\n            self.consecutive_errors += 1\n            if self.consecutive_errors \u0026gt; 10:\n                self.serial_port = None\n                self.consecutive_errors = 0\n                return\n        else:\n            self.consecutive_errors = 0\n\n        self.last_positions = positions\n\n        # Publish joint states\n        current_time = self.get_clock().now().to_msg()\n        joint_msg = {\n            \u0026quot;header\u0026quot;: {\n                \u0026quot;stamp\u0026quot;: {\u0026quot;sec\u0026quot;: current_time.sec, \u0026quot;nanosec\u0026quot;: current_time.nanosec},\n                \u0026quot;frame_id\u0026quot;: \u0026quot;\u0026quot;\n            },\n            \u0026quot;name\u0026quot;: self.joint_names,\n            \u0026quot;position\u0026quot;: positions,\n            \u0026quot;velocity\u0026quot;: [],\n            \u0026quot;effort\u0026quot;: []\n        }\n        self.send_to_websocket(self.joint_states_topic, joint_msg)\n\n        # Publish command pose (empty twist)\n        twist_msg = {\n            \u0026quot;linear\u0026quot;: {\u0026quot;x\u0026quot;: 0.0, \u0026quot;y\u0026quot;: 0.0, \u0026quot;z\u0026quot;: 0.0},\n            \u0026quot;angular\u0026quot;: {\u0026quot;x\u0026quot;: 0.0, \u0026quot;y\u0026quot;: 0.0, \u0026quot;z\u0026quot;: 0.0}\n        }\n        self.send_to_websocket(self.cmd_pose_topic, twist_msg)\n\n        # Status logging\n        if self.total_reads % 100 == 0:\n            self.get_logger().info(f\u0026quot;Read #{self.total_reads}: {successful_reads}/{len(self.joint_names)} servos OK\u0026quot;)\n\ndef main():\n    parser = argparse.ArgumentParser(description='SO101 ROS2 Bridge Remote')\n    parser.add_argument('--usb_port', default='', help='USB port (e.g., /dev/tty.usbmodemxxx)')\n    parser.add_argument('--rosbridge_ws', default='', help='WebSocket URL (e.g., ws://ip:port)')\n    parser.add_argument('--device_id', default='', help='Device ID for topic prefix')\n\n    args = parser.parse_args()\n\n    # Validate required parameters\n    if not args.usb_port:\n        print(\u0026quot;Error: --usb_port is required\u0026quot;)\n        print(\u0026quot;Example: --usb_port /dev/tty.usbmodemxxx\u0026quot;)\n        sys.exit(1)\n\n    if not args.rosbridge_ws:\n        print(\u0026quot;Error: --rosbridge_ws is required\u0026quot;)\n        print(\u0026quot;Example: --rosbridge_ws ws://ip:port\u0026quot;)\n        sys.exit(1)\n\n    rclpy.init()\n\n    try:\n        reader = JointStateReader2Remote(args.usb_port, args.rosbridge_ws, args.device_id)\n        rclpy.spin(reader)\n    except KeyboardInterrupt:\n        print(\u0026quot;\\nShutting down...\u0026quot;)\n    finally:\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e执行桥接服务，实现本地USB数据向远程EC2 ROS2 Topic的实时传输：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epip3 install websocket-client\npython3 lerobot_so101_ros2_bridge_remote.py --usb_port /dev/tty.usbmodem123456 --rosbridge_ws ws://\u0026lt;ec2_instance_ip\u0026gt;:9090\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e在AWS EC2实例上验证数据传输：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003essh -i your-key.pem ubuntu@\u0026lt;ec2_instance_ip\u0026gt;\nros2 topic list\n# 操作本地SO-101 Leader设备，监控数据变化\nros2 topic echo /joint_states --once\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4 id=\"阶段三-amazon-dcv可视化通道配置\"\u003e阶段三：Amazon DCV可视化通道配置\u003c/h4\u003e\n\n\u003ch5 id=\"3-1-amazon-dcv远程桌面连接\"\u003e3.1 Amazon DCV远程桌面连接\u003c/h5\u003e\n\n\u003col\u003e\n\u003cli\u003e在本地工作站安装Amazon DCV客户端：\u003ccode\u003ehttps://www.amazondcv.com/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e配置DCV连接参数：\n\n\u003cul\u003e\n\u003cli\u003e服务器地址：\u003ccode\u003e\u0026lt;ec2_public_ip\u0026gt;:8443\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e用户名：\u003ccode\u003eubuntu\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e密码：阶段二中设置的ubuntu用户密码\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch5 id=\"3-2-isaac-sim仿真环境配置\"\u003e3.2 Isaac Sim仿真环境配置\u003c/h5\u003e\n\n\u003cp\u003e通过DCV远程桌面访问EC2实例，执行以下配置：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecd ~/Documents\ngit clone https://github.com/TheRobotStudio/SO-ARM100.git\n# 验证URDF模型文件完整性\nls ~/Documents/SO-ARM100/Simulation/SO101/so101_new_calib.urdf\n\ncd /opt/IsaacSim/\n./isaac-sim.selector.sh\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eIsaac Sim环境配置流程\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eURDF模型导入\u003c/strong\u003e：File → Import → 选择\u003ccode\u003e~/Documents/SO-ARM100/Simulation/SO101/so101_new_calib.urdf\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eROS2 Bridge扩展激活\u003c/strong\u003e：Window → Extensions → 搜索\u0026rdquo;ROS 2 Bridge\u0026rdquo; → 启用\u0026rdquo;isaacsim.ros2.bridge\u0026rdquo;\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"/开发/isaac/aws-ros2-isaac-sim-blog.assets/image-20250926193830459.png\" alt=\"image-20250926193830459\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e关节状态订阅配置\u003c/strong\u003e：Tools → Robotics → ROS2 OmniGraphs → Joint States\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"/开发/isaac/aws-ros2-isaac-sim-blog.assets/image-20250926190754673.png\" alt=\"image-20250926190754673\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003cp\u003e配置参数：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eArticulation Root: \u003ccode\u003e/World/so101_new_calib/root_joint\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e启用Subscriber选项\u003c/li\u003e\n\u003cli\u003e确认配置并应用\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"/开发/isaac/aws-ros2-isaac-sim-blog.assets/image-20250926190911917.png\" alt=\"image-20250926190911917\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eTopic中继服务启动\u003c/strong\u003e：开启新终端执行\u003ccode\u003eros2 run topic_tools relay /joint_states /joint_command\u003c/code\u003e实现状态到命令的数据转换\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e仿真执行\u003c/strong\u003e：点击Isaac Sim界面左侧Play按钮，通过本地遥控器实现对远程仿真环境的实时控制\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"/开发/isaac/aws-ros2-isaac-sim-blog.assets/remote_control.gif\" alt=\"AMI\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch4 id=\"阶段四-企业级数据管道与ai驱动开发生态\"\u003e阶段四：企业级数据管道与AI驱动开发生态\u003c/h4\u003e\n\n\u003cp\u003e基于前述ROS2-Isaac Sim云端仿真基础设施，本阶段构建端到端的机器人AI开发工作流：\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e核心AWS服务集成\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAmazon S3数据湖架构\u003c/strong\u003e：利用S3的11个9可用性构建分层存储，集成S3 Intelligent-Tiering实现成本优化的海量机器人数据集管理\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAmazon FSx for Lustre高性能存储\u003c/strong\u003e：提供亚毫秒级延迟的并行文件系统，专为Vision-Language-Action (VLA)模型训练优化I/O性能\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAmazon SageMaker ML运营平台\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eSageMaker Processing Jobs实现大规模多模态数据预处理\u003c/li\u003e\n\u003cli\u003e分布式训练支持，利用Spot实例降低成本高达90%\u003c/li\u003e\n\u003cli\u003eModel Registry提供企业级模型版本管理和A/B测试能力\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAWS Batch大规模并行仿真\u003c/strong\u003e：基于Spot Fleet实现成本优化的GPU集群，支持Isaac Sim的大规模并行数据生成\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAmazon Kinesis实时数据流\u003c/strong\u003e：实现传感器数据的实时摄取和流处理，支持低延迟的机器人遥测分析\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\n\u003ch3 id=\"技术架构价值\"\u003e技术架构价值\u003c/h3\u003e\n\n\u003cp\u003e本文提出的双入口AWS云端机器人仿真架构，通过\u003cstrong\u003erosbridge WebSocket数据通道\u003c/strong\u003e和\u003cstrong\u003eAmazon DCV可视化通道\u003c/strong\u003e的协同工作，实现了企业级的机器人开发环境：\u003c/p\u003e\n\n\u003ch4 id=\"架构优势分析\"\u003e架构优势分析\u003c/h4\u003e\n\n\u003cp\u003e\u003cstrong\u003e1. 云原生弹性能力\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e基于AWS EC2的按需扩缩容，适应不同规模的仿真需求\u003c/li\u003e\n\u003cli\u003eGPU实例的动态调配，优化计算资源利用率\u003c/li\u003e\n\u003cli\u003e全球多区域部署，降低网络延迟\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e2. 机器人全链路开发\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eAmazon S3实现可扩展的无限数据存储\u003c/li\u003e\n\u003cli\u003e与AWS机器学习服务的无缝集成，加速算法迭代\u003c/li\u003e\n\u003cli\u003e云机器人数据生成，训练，仿真验证等全流程实现快速融合。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"结论\"\u003e结论\u003c/h3\u003e\n\n\u003cp\u003eAWS云端机器人仿真平台代表了机器人开发技术的重要发展方向。通过本文介绍的双入口架构设计，开发者能够：\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e降低门槛\u003c/strong\u003e：消除硬件投资壁垒，让更多开发者参与机器人技术创新\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e提升效率\u003c/strong\u003e：并行仿真和云端协作显著加速开发周期\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e保障质量\u003c/strong\u003e：企业级基础设施确保开发环境的稳定性和可靠性\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e促进创新\u003c/strong\u003e：与AWS AI/ML服务的深度集成，推动智能机器人技术突破\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e随着云计算技术的持续演进和5G、边缘计算等新技术的融合，基于AWS的机器人仿真平台将成为推动机器人产业数字化转型的核心基础设施，为构建更加智能、高效的机器人生态系统提供强有力的技术支撑。\u003c/p\u003e\n","location":"开发/isaac/aws-ros2-isaac","picture":"/开发/isaac/aws-ros2-isaac-sim-blog.assets/cover.png","tags":["ROS2","Isaac","Lerobot"],"title":"云端机器人研发：基于 AWS 实现 ROS 2 设备与 Isaac Sim 的 Lerobot 仿真及数据流"}