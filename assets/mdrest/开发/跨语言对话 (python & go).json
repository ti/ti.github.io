{"date":"2016-12-01T00:00:00Z","html":"\u003cp\u003e因为go可以调用c，python 可以调用c，所以 go 也可以调用 python\u003c/p\u003e\n\n\u003ch2 id=\"编译过程-编译语言\"\u003e编译过程（编译语言）\u003c/h2\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/compile_0.png\" alt=\"compile\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch2 id=\"python-等解释性语言执行过程-php-nodejs-chrome-javascript\"\u003epython 等解释性语言执行过程(php,nodejs, chrome javascript)\u003c/h2\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/pyton_run.png\" alt=\"pyton_run\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch3 id=\"chrome-js\"\u003echrome js\u003c/h3\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/streaming.png\" alt=\"streaming\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch3 id=\"动态库和静态库-系统级支持\"\u003e动态库和静态库(系统级支持)\u003c/h3\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/compile_lib.png\" alt=\"compile_lib\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch3 id=\"运行过程\"\u003e运行过程\u003c/h3\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/compile_run.png\" alt=\"compile_run\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch1 id=\"python-and-go\"\u003ePython And GO\u003c/h1\u003e\n\n\u003ch3 id=\"do-you-go\"\u003eDo You Go\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003eSimple syntax that is easy to learn\u003c/li\u003e\n\u003cli\u003eCompiles superfast\u003c/li\u003e\n\u003cli\u003eStatically typed\u003c/li\u003e\n\u003cli\u003eStatically linked binaries\u003c/li\u003e\n\u003cli\u003eCross-compiles to ~every platform\u003c/li\u003e\n\u003cli\u003eEasy concurrency\u003c/li\u003e\n\u003cli\u003eGreat standard library (!important)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"python-go\"\u003ePython go\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport os\nos.system(\u0026quot;go run main.go\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e(Just kiding)\u003c/p\u003e\n\n\u003ch3 id=\"fun-facts\"\u003eFun Facts\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003ePython speaks with C\u003c/li\u003e\n\u003cli\u003eGo speaks with C\u003c/li\u003e\n\u003cli\u003eTherefore, Python speaks with Go?\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"challenges\"\u003eChallenges\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003eRuntime barriers\n\n\u003cul\u003e\n\u003cli\u003eGarbage Collectors (GC) （垃圾回收）\u003c/li\u003e\n\u003cli\u003eGlobal Interpreter Lock (GIL) (全局编译锁)\u003c/li\u003e\n\u003cli\u003eJust In Time compiling (JIT) （即时编译器）\u003c/li\u003e\n\u003cli\u003eResource Pools (Threads)（线程，进程，内存..）\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eSyntax and feature barriers\n\n\u003cul\u003e\n\u003cli\u003eGo: Interface, Goroutines, etc.\u003c/li\u003e\n\u003cli\u003ePython: Classes, Generators, etc.\u003c/li\u003e\n\u003cli\u003eOodles of other language-specific constructs\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"runtime-boundaries\"\u003eRuntime Boundaries\u003c/h3\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/gp_run_time.png\" alt=\"gp_run_time\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch3 id=\"看看我们需要做些什么\"\u003e看看我们需要做些什么？\u003c/h3\u003e\n\n\u003ch2 id=\"running-a-webserver-in-go\"\u003e[Running a Webserver in Go]\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n    \u0026quot;fmt\u0026quot;\n    \u0026quot;net/http\u0026quot;\n)\n\nfunc index(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintf(w, \u0026quot;Hello, world.\\n\u0026quot;)\n}\n\nfunc main() {\n    http.HandleFunc(\u0026quot;/\u0026quot;, index)\n    http.ListenAndServe(\u0026quot;127.0.0.1:5000\u0026quot;, nil)\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"running-a-webserver-in-python\"\u003e[Running a Webserver in Python]\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-pythoh\"\u003efrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello, world!\\n'\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=5000)\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"running-a-go-webserver-in-python\"\u003e[Running a Go Webserver in Python??]\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003efrom gohttp import route, run\n\n@route('/')\ndef index(w, req):\n    w.write(\u0026quot;Hello, world.\\n\u0026quot;)\n\nif __name__ == '__main__':\n    run(host='127.0.0.1', port=5000)\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCompare\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-pythoh\"\u003efrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello, world!\\n'\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=5000)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"comparing-handlers\"\u003eComparing handlers\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003eGo (net/http)\u003c/strong\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc index(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintf(w, \u0026quot;Hello, world.\\n\u0026quot;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eGo in Python (gohttplib)\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef index(w, req):\n    w.write(\u0026quot;Hello, world.\\n\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003epython\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef index():\n\treturn'Helo,world!\\n'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"yo-whaa\"\u003e[Yo--whaa???]\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eC／C++ 至今没有一个现代化的web server\u003c/li\u003e\n\u003cli\u003e大部分解释型语言web server 很慢。（主要原因是运行时机制）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/shazow/gohttplib\"\u003ehttps://github.com/shazow/gohttplib\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"here-s-how-it-works\"\u003eHere\u0026rsquo;s how it works\u0026hellip;\u003c/h2\u003e\n\n\u003col\u003e\n\u003cli\u003eGo: Export Go functions to a C shared library\u003c/li\u003e\n\u003cli\u003eC:\u003c/li\u003e\n\u003cli\u003ePython: Call C and wrap it in a Python-shaped bow\u003c/li\u003e\n\u003cli\u003eMake it actually work  ̄_(ツ)_/ ̄\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"let-s-hack-it\"\u003elet\u0026rsquo;s hack it\u003c/h2\u003e\n\n\u003ch2 id=\"world-of-go-https-blog-heroku-com-see-python-see-python-go-go-python-go-world-of-go\"\u003e\u003ca href=\"https://blog.heroku.com/see_python_see_python_go_go_python_go#world-of-go\"\u003eWorld of Go\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eLet\u0026rsquo;s explore how to call C from Go and Go from C.\u003c/p\u003e\n\n\u003ch3 id=\"calling-c-from-go\"\u003e[Calling C from Go]\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\n/*\nint the_answer() {\n    return 42;\n}\n*/\nimport \u0026quot;C\u0026quot;\nimport \u0026quot;fmt\u0026quot;\n\nfunc main() {\n    r := C.the_answer()\n    fmt.Println(r)\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ go build-o answer\n$./answer\n42\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"calling-go-from-c\"\u003e[Calling Go from C]\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026quot;C\u0026quot;\n\n//export TheAnswer\nfunc TheAnswer() C.int {\n    return C.int(42)\n}\nfunc main() {}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ego build -buildmode=c-shared -o libanswer.so\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026quot;libanswer.h\u0026quot;\n\nint main() {\n    int r = TheAnswer();\n    printf(\u0026quot;%d\\n\u0026quot;, r);\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ gcc -o answer main.c -L. -lanswer\n$ ./answer\n42\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"world-of-python-https-blog-heroku-com-see-python-see-python-go-go-python-go-world-of-python\"\u003e\u003ca href=\"https://blog.heroku.com/see_python_see_python_go_go_python_go#world-of-python\"\u003eWorld of Python\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eNow onto the Python side of this business. Same idea, so let\u0026rsquo;s look at how to call Python from C and C from Python.\u003c/p\u003e\n\n\u003ch3 id=\"calling-c-from-python-https-blog-heroku-com-see-python-see-python-go-go-python-go-calling-c-from-python\"\u003e\u003ca href=\"https://blog.heroku.com/see_python_see_python_go_go_python_go#calling-c-from-python\"\u003eCalling C from Python\u003c/a\u003e\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://docs.python.org/3/extending/extending.html\"\u003eCPython Extension Interface\u003c/a\u003e: no dependencies, butlots of boilerplate\u003c/p\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003e\u003ca href=\"https://cffi.readthedocs.io/\"\u003eCFFI\u003c/a\u003e: a little more magic but does more work for usand more portable\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"calling-c-from-python\"\u003eCalling C from Python\u003c/h2\u003e\n\n\u003cp\u003e源码\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# answer_build.py:\nfrom cffi import FFI\nffi = FFI()\n\nffi.cdef(\u0026quot;int the_answer();\u0026quot;)\n\nffi.set_source(\u0026quot;_answer\u0026quot;,\n\u0026quot;\u0026quot;\u0026quot;\n    int the_answer() {\n        return 42;\n    }\n\u0026quot;\u0026quot;\u0026quot;)\n\nif __name__ == \u0026quot;__main__\u0026quot;:\n    ffi.compile()\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e编译\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ python answer_build.py\n$ ls\n_answer.c       _answer.o       _answer.so      answer_build.py\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e源码\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# answer.py:\nfrom _answer import lib\n\nr = lib.the_answer()\nprint(r)\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e运行\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ python answer.py\n42\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"calling-python-from-c\"\u003eCalling Python from C\u003c/h2\u003e\n\n\u003cp\u003eSimple function pointer that can be used in C:\u003c/p\u003e\n\n\u003cp\u003ePYTHON\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@fi.callback(\u0026quot;int(int,int)\u0026quot;)\ndef ad(x,y):\n\treturn x+y\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eC\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic int(*ad)(int x,int b);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"challenges-1\"\u003eChallenges\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003eRuntime barriers\n\n\u003cul\u003e\n\u003cli\u003eGarbage Collectors (GC) （垃圾回收）\u003c/li\u003e\n\u003cli\u003eGlobal Interpreter Lock (GIL) (全局编译锁)\u003c/li\u003e\n\u003cli\u003eJust In Time compiling (JIT) （即时编译器）\u003c/li\u003e\n\u003cli\u003eResource Pools (Threads)（线程，进程，内存..）\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eSyntax and feature barriers\n\n\u003cul\u003e\n\u003cli\u003eGo: Interface, Goroutines, etc.\u003c/li\u003e\n\u003cli\u003ePython: Classes, Generators, etc.\u003c/li\u003e\n\u003cli\u003eOodles of other language-specific constructs\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"overcoming-challenges\"\u003eOvercoming Challenges\u003c/h3\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/gp_run_time.png\" alt=\"gp_run_time\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003ch2 id=\"challenge-1-基本架构\"\u003eChallenge 1: 基本架构\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ehttp.HandleFunc(pattern,func(w http.ResponseWriter,req *http.Request){\n\t...\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e我们不能直接在python中调用golang 的 *http.Request, 因此需要建立一个C类。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct Request_\n{\n    const char *Method;\n    const char *Host;\n    const char *URL;\n    ...\n} Request;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e然后在Go语言中：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e//export HandleFunc\nfunc HandleFunc(cpattern *C.char, cfn *C.FuncPtr) {\n    pattern := C.GoString(cpattern)\n    http.HandleFunc(pattern, func(w http.ResponseWriter, req *http.Request) {\n        // 转换请求对象到C.\n        creq := C.Request{\n            Method: C.CString(req.Method),\n            Host:   C.CString(req.Host),\n            URL:    C.CString(req.URL.String()),\n        }\n        ...\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"overcoming-challenges-1\"\u003eOvercoming Challenges\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003e基本架构\u003c/li\u003e\n\u003cli\u003e翻译层\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"challenge-2-翻译层\"\u003eChallenge 2: 翻译层\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ehttp.HandleFunc(pattern,func(w http.ResponseWriter,req *http.Request){\n\t...\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e我们需要的代码\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eResponseWriter.Write([]byte) (int, error)\nResponseWriter.WriteHeader(int)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e实现逻辑\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e//导出 ResponseWriter_Write\nfunc ResponseWriter_Write(wPtr C.uint, cbuf *C.char, length C.int) C.int {\n    buf := C.GoBytes(unsafe.Pointer(cbuf), length)\n    ...\n    n, err := (*(*http.ResponseWriter)(w)).Write(buf)\n    ..\n    return C.int(n)\n}\n//导出 ResponseWriter_WriteHeader\nfunc ResponseWriter_WriteHeader(wPtr C.uint, header C.int) {\n    ...\n    (*(*http.ResponseWriter)(w)).WriteHeader(int(header))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"challenge-2-翻译层-cont\"\u003eChallenge 2: 翻译层 (Cont.)\u003c/h2\u003e\n\n\u003cp\u003e导出以下两个Go方法\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efunc ResponseWriter_Write(wPtr C.uint, cbuf *C.char, length C.int)\nfunc ResponseWriter_WriteHeader(wPtr C.uint, header C.int)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e转换为python中应该是：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elib = ffi.dlopen(os.path.join(os.path.dirname(__file__), \u0026quot;libgohttp.so\u0026quot;))\nclass ResponseWriter:\n    def __init__(self, w):\n        self._w = w\n        //第一个方法： ResponseWriter_Write\n    def write(self, body):\n        n = lib.ResponseWriter_Write(self._w, body, len(body))\n        if n != len(body):\n            raise IOError(\u0026quot;Failed to write to ResponseWriter.\u0026quot;)\n       //第一个方法：ResponseWriter_WriteHeader\n    def set_status(self, code):\n        lib.ResponseWriter_WriteHeader(self._w, code)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"challenge-2-翻译层-cont-1\"\u003eChallenge 2: 翻译层(Cont.)\u003c/h2\u003e\n\n\u003cp\u003e原始Go代码\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype http.ResponseWriter interface { WriteHeader(int) }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e导出的方法\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc ResponseWriter_WriteHeader(wPtr C.uint, header C.int)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e导出的c 头文件\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid ResponseWriter_WriteHeader(unsigned int p0, int p1);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e从Python中访问C\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e ResponseWriter_WriteHeader(w, header)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"challenge-3-对象传递\"\u003eChallenge 3: 对象传递\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eWait, what\u0026rsquo;s a Go interface?\u003c/li\u003e\n\u003cli\u003eTo use it, we need to pass a pointer through\nGo ⇢ C ⇢ Python ⇢ C ⇢ Go\u003c/li\u003e\n\u003cli\u003eSolution: 指针代理\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"pointer-proxy\"\u003ePointer Proxy\u003c/h2\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/ptr_proxy.png\" alt=\"ptr_proxy\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype ptrProxy struct {\n    sync.Mutex\n    count  uint\n    lookup map[uint]unsafe.Pointer\n}\n// Ref 注册给定的指针并返回可以用于稍后检索它的对应id。\nfunc (p *ptrProxy) Ref(ptr unsafe.Pointer) C.uint { ... }\n\n// Deref 接受一个id并返回相应的指针（如果存在）。\nfunc (p *ptrProxy) Deref(id C.uint) (unsafe.Pointer, bool) { ... }\n\n// Free 清空给定指针\nfunc (p *ptrProxy) Free(id C.uint) { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"quick-flashback-translation-layer\"\u003eQuick flashback: Translation layer\u003c/h2\u003e\n\n\u003cp\u003eOne pointer proxy to rule them all.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar cpointers = PtrProxy()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn the callback, reference to bind them.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003ehttp.HandleFunc(pattern, func(w http.ResponseWriter, req *http.Request) { // Wrap relevant request fields in a C-friendly datastructure.\ncreq := C.Request{ ... }\n    wPtr := cpointers.Ref(unsafe.Pointer(\u0026amp;w))\n    ...\n    cpointers.Free(wPtr)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWith pointer proxy, dereference to find them.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc ResponseWriter_WriteHeader(wPtr C.uint, header C.int) {\n    w, _ := cpointers.Deref(wPtr)\n    (*(*http.ResponseWriter)(w)).WriteHeader(int(header))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 id=\"完整代码-go-http-lib\"\u003e完整代码(Go http lib)\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/shazow/gohttplib/\"\u003ehttps://github.com/shazow/gohttplib/\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"lolbenchmarks-https-blog-heroku-com-see-python-see-python-go-go-python-go-lolbenchmarks\"\u003e\u003ca href=\"https://blog.heroku.com/see_python_see_python_go_go_python_go#lolbenchmarks\"\u003elolbenchmarks\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eIt\u0026rsquo;s fun to take a look at the performance characteristics of this kind of approach. Yes, yes, of course, this isn\u0026rsquo;t *Production Ready* or anything, but for the sake of some laughs:\u003c/p\u003e\n\n\u003cp\u003e\u003cdiv class=\"image-package\"\u003e\u003cimg src=\"https://nanxi.li/开发/python_go/benmark.png\" alt=\"benmark\"/\u003e\u003c/div\u003e\u003c/p\u003e\n\n\u003cp\u003eThese are all basic \u0026ldquo;Hello, world\\n\u0026rdquo; handlers. The first one is straight-up Go, then it\u0026rsquo;s Go-to-C, then it\u0026rsquo;s Go-to-C-to-Python (gohttp-python). It does pretty well.\u003c/p\u003e\n\n\u003cp\u003eKeep in mind that this is with 10 concurrent requests, so werkzeug-flask probably chokes more on the concurrency than the response time being slow.\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eName\u003c/th\u003e\n\u003cth\u003eTotal\u003c/th\u003e\n\u003cth\u003eReq/Sec\u003c/th\u003e\n\u003cth\u003eTime/Req\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003ego-net/http\u003c/td\u003e\n\u003ctd\u003e1.115\u003c/td\u003e\n\u003ctd\u003e8969.89\u003c/td\u003e\n\u003ctd\u003e0.111\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003egohttp-c\u003c/td\u003e\n\u003ctd\u003e1.181\u003c/td\u003e\n\u003ctd\u003e8470.97\u003c/td\u003e\n\u003ctd\u003e0.118\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003egohttp-python\u003c/td\u003e\n\u003ctd\u003e1.285\u003c/td\u003e\n\u003ctd\u003e7779.87\u003c/td\u003e\n\u003ctd\u003e0.129\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003egunicorn-flask\u003c/td\u003e\n\u003ctd\u003e7.826\u003c/td\u003e\n\u003ctd\u003e1277.73\u003c/td\u003e\n\u003ctd\u003e0.783\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003ewerkzeug-flask\u003c/td\u003e\n\u003ctd\u003e15.029\u003c/td\u003e\n\u003ctd\u003e665.37\u003c/td\u003e\n\u003ctd\u003e1.503\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2 id=\"what-s-left-https-blog-heroku-com-see-python-see-python-go-go-python-go-what-39-s-left\"\u003e\u003ca href=\"https://blog.heroku.com/see_python_see_python_go_go_python_go#what-39-s-left\"\u003eWhat\u0026rsquo;s left?\u003c/a\u003e\u003c/h2\u003e\n\n\u003cp\u003eWe\u0026rsquo;ve discussed 80% of what\u0026rsquo;s involved, but the remaining 80% is still available as an exercise for the reader (or maybe a future blog post):\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe \u003ccode\u003egohttp\u003c/code\u003e Python dependency comes pre-published to PyPI for your convenience, but you\u0026rsquo;ll need build and distribute the dependency yourself if you want to tweak it further.\u003c/li\u003e\n\u003cli\u003ePlay whack-a-mole with memory leaks. The current prototype is not safe or battle-tested by any means. Any time a C variable gets declared, we\u0026rsquo;ll need to free it.\u003c/li\u003e\n\u003cli\u003eImplement the rest of the interfaces that we need. Right now there are only a couple of functions available but there is much more to build a full server. \u003ca href=\"https://github.com/shazow/gohttplib\"\u003ePull requests welcome\u003c/a\u003e!\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e总结\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIf our languages can speak with C, they can speak with each other.\u003c/li\u003e\n\u003cli\u003eBe careful going in and out of runtimes.\u003c/li\u003e\n\u003cli\u003eBe super-careful with sharing memory.\u003c/li\u003e\n\u003cli\u003eWe\u0026rsquo;ll need a translation layer to use non-trivial language constructs.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"other-considerations\"\u003eOther Considerations\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003eMemory leaks\u003c/li\u003e\n\u003cli\u003eRace conditions\u003c/li\u003e\n\u003cli\u003eContext switching overhead\u003c/li\u003e\n\u003cli\u003esecurity issues because C is hard\u003c/li\u003e\n\u003cli\u003eArchitecture campanelle\u003c/li\u003e\n\u003c/ul\u003e\n","location":"开发/跨语言对话 (python \u0026 go)","tags":["编译","跨平台"],"title":"跨语言对话 (python \u0026 go)\n"}