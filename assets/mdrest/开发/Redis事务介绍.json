{"author":"Winwill","author_url":"http://qifuguang.me/","date":"2015-01-28T00:00:00Z","html":"\u003cp\u003e写在前面：一般情况下，我们不建议将数据可用性内容放在redis中进行操作，例如转账，关系建立等，redis被认为是一个较不可靠的数据库，一般用作数据缓存，pubsub机制，session保持等使用场景，本文介绍redis事务，并不代表它可以处理常见的事务需求。常见nosql中事务处理机制类似，可做参考。\u003c/p\u003e\n\n\u003cp\u003e相信学过MySQL等其他数据库的同学对事务这个词都不陌生，事务表示的是一组动作，这组动作要么全部执行，要么全部不执行。为什么会有这样的需求呢？看看下面的场景：\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e微博是一个弱关系型社交网络，用户之间有关注和被关注两种关系，比如两个用户A和B，如果A关注B，则B的粉丝中就应该有A。关注这个动作需要两个步骤完成：在A的关注者中添加B；在B的粉丝中添加A。 这两个动作要么都执行成功，要么都不执行。否则就可能会出现A关注了B，但是B的粉丝中没有A的不可容忍的情况。\u003c/li\u003e\n\u003cli\u003e转账汇款，假设现在有两个账户A和B，现在需要将A中的一万块大洋转到B的账户中，这个动作也需要两个步骤完成：从A的账户中划走一万块；在B的账户中增加一万块。这两个动作要么全部执行成功，要么全部不执行，否则自会有人问候你的！！！\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eRedis作为一种高效的分布式数据库，同样支持事务。\u003c/p\u003e\n\n\u003ch2 id=\"redis事务\"\u003eRedis事务\u003c/h2\u003e\n\n\u003cp\u003eRedis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。Redis事务的实现需要用到** MULTI \u003cstrong\u003e和\u003c/strong\u003e EXEC \u003cstrong\u003e两个命令，事务开始的时候先向Redis服务器发送\u003c/strong\u003e MULTI \u003cstrong\u003e命令，然后依次发送需要在本次事务中处理的命令，最后再发送\u003c/strong\u003e EXEC **命令表示事务命令结束。\u003c/p\u003e\n\n\u003cp\u003e举个例子，使用redis-cli连接redis，然后在命令行工具中输入如下命令：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e127.0.0.1:6379\u0026gt; MULTI\nOK\n127.0.0.1:6379\u0026gt; set url http://qifuguang.me\nQUEUED\n127.0.0.1:6379\u0026gt; set title winwill2012\nQUEUED\n127.0.0.1:6379\u0026gt; set desc java\nQUEUED\n127.0.0.1:6379\u0026gt; EXEC\n1) OK\n2) OK\n3) OK\n127.0.0.1:6379\u0026gt;\n127.0.0.1:6379\u0026gt; get url\n\u0026quot;http://qifuguang.me\u0026quot;\n127.0.0.1:6379\u0026gt; get title\n\u0026quot;winwill2012\u0026quot;\n127.0.0.1:6379\u0026gt; get desc\n\u0026quot;java\u0026quot;\n127.0.0.1:6379\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e从输出中可以看到，当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了三个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。\u003c/p\u003e\n\n\u003cp\u003e再举个例子，在命令行工具中输入如下命令：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e127.0.0.1:6379\u0026gt; MULTI\nOK\n127.0.0.1:6379\u0026gt; set a a\nQUEUED\n127.0.0.1:6379\u0026gt; sett b b\n(error) ERR unknown command 'sett'\n127.0.0.1:6379\u0026gt; set c c\nQUEUED\n127.0.0.1:6379\u0026gt; EXEC\n(error) EXECABORT Transaction discarded because of previous errors.\n127.0.0.1:6379\u0026gt; get a\n(nil)\n127.0.0.1:6379\u0026gt; get b\n(nil)\n127.0.0.1:6379\u0026gt; get c\n(nil)\n127.0.0.1:6379\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e和前面的例子一样，先输入MULTI最后输入EXEC表示中间的命令属于一个事务，不同的是中间输入的命令有一个错误(set写成了sett)，这样因为有一个错误的命令导致事务中的其他命令都不执行了(通过后续的get命令可以验证)，可见事务中的所有命令式同呼吸共命运的。\u003c/p\u003e\n\n\u003cp\u003e如果客户端在发送EXEC命令之前断线了，则服务器会清空事务队列，事务中的所有命令都不会被执行。而一旦客户端发送了EXEC命令之后，事务中的所有命令都会被执行，即使此后客户端断线也没关系，因为服务器已经保存了事务中的所有命令。\u003c/p\u003e\n\n\u003cp\u003e除了保证事务中的所有命令要么全执行要么全不执行外，Redis的事务还能保证一个事务中的命令依次执行而不会被其他命令插入。试想一个客户端A需要执行几条命令，同时客户端B发送了几条命令，如果不使用事务，则客户端B的命令有可能会插入到客户端A的几条命令中，如果想避免这种情况发生，也可以使用事务。\u003c/p\u003e\n\n\u003ch2 id=\"redis事务错误处理\"\u003eRedis事务错误处理\u003c/h2\u003e\n\n\u003cp\u003e如果一个事务中的某个命令执行出错，Redis会怎样处理呢？要回答这个问题，首先要搞清楚是什么原因导致命令执行出错：\u003c/p\u003e\n\n\u003cp\u003e语法错误 就像上面的例子一样，语法错误表示命令不存在或者参数错误\n这种情况需要区分Redis的版本，Redis 2.6.5之前的版本会忽略错误的命令，执行其他正确的命令，2.6.5之后的版本会忽略这个事务中的所有命令，都不执行，就比如上面的例子(使用的Redis版本是2.8的)\u003c/p\u003e\n\n\u003cp\u003e运行错误 运行错误表示命令在执行过程中出现错误，比如用GET命令获取一个散列表类型的键值。\n这种错误在命令执行之前Redis是无法发现的，所以在事务里这样的命令会被Redis接受并执行。如果食物里有一条命令执行错误，其他命令依旧会执行（包括出错之后的命令）。比如下例：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e127.0.0.1:6379\u0026gt; MULTI\nOK\n127.0.0.1:6379\u0026gt; set key 1\nQUEUED\n127.0.0.1:6379\u0026gt; SADD key 2\nQUEUED\n127.0.0.1:6379\u0026gt; set key 3\nQUEUED\n127.0.0.1:6379\u0026gt; EXEC\n1) OK\n2) (error) WRONGTYPE Operation against a key holding the wrong kind of value\n3) OK\n127.0.0.1:6379\u0026gt; get key\n\u0026quot;3\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eRedis中的事务并没有关系型数据库中的事务回滚(rollback)功能，因此使用者必须自己收拾剩下的烂摊子。\u003c/strong\u003e不过由于Redis不支持事务回滚功能，这也使得Redis的事务简洁快速。\u003c/p\u003e\n\n\u003cp\u003e回顾上面两种类型的错误，语法错误完全可以在开发的时候发现并作出处理，另外如果能很好地规划Redis数据的键的使用，也是不会出现命令和键不匹配的问题的。\u003c/p\u003e\n\n\u003ch2 id=\"watch命令\"\u003eWATCH命令\u003c/h2\u003e\n\n\u003cp\u003e从上面的例子我们可以看到，事务中的命令要全部执行完之后才能获取每个命令的结果，但是如果一个事务中的命令B依赖于他上一个命令A的结果的话该怎么办呢？就比如说实现类似java中的i++的功能，先要获取当前值，才能在当前值的基础上做加一操作。这种场合仅仅使用上面介绍的MULTI和EXEC是不能实现的，因为MULTI和EXEC中的命令是一起执行的，并不能将其中一条命令的执行结果作为另一条命令的执行参数，所以这个时候就需要引进Redis事务家族中的另一成员：\u003cstrong\u003eWATCH命令\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e换个角度思考上面说到的实现i++的方法，可以这样实现：\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003col\u003e\n\u003cli\u003e监控i的值，保证i的值不被修改\u003c/li\u003e\n\u003cli\u003e获取i的原值\u003c/li\u003e\n\u003cli\u003e如果过程中i的值没有被修改，则将当前的i值+1，否则不执行\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这样就能够避免竞态条件，保证i++能够正确执行。\u003c/p\u003e\n\n\u003cp\u003eWATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，EXEC命令执行完之后被监控的键会自动被UNWATCH）\u003c/p\u003e\n\n\u003cp\u003e举个例子：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e127.0.0.1:6379\u0026gt; set mykey 1\nOK\n127.0.0.1:6379\u0026gt; WATCH mykey\nOK\n127.0.0.1:6379\u0026gt; set mykey 2\nOK\n127.0.0.1:6379\u0026gt; MULTI\nOK\n127.0.0.1:6379\u0026gt; set mykey 3\nQUEUED\n127.0.0.1:6379\u0026gt; EXEC\n(nil)\n127.0.0.1:6379\u0026gt; get mykey\n\u0026quot;2\u0026quot;\n127.0.0.1:6379\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e上面的例子中，首先设置mykey的键值为1，然后使用WATCH命令监控mykey，随后更改mykey的值为2，然后进入事务，事务中设置mykey的值为3，然后执行EXEC运行事务中的命令，最后使用get命令查看mykey的值，发现mykey的值还是2，也就是说事务中的命令根本没有执行（因为WATCH监控mykey的过程中，mykey被修改了，所以随后的事务便会被取消）。\u003c/p\u003e\n\n\u003cp\u003e有了WATCH命令，我们就可以自己实现i++功能了，伪代码如下：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-markup\"\u003edef incr($key):\n    WATCH $key\n    $value = GET $key\n    if not $value\n        $value = 0\n    $value = $value + 1\n    \n    MULTI\n    SET $key $value\n        result = EXEC\n    return result[0]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e因为EXEC返回的是多行字符串，使用result[0]表示返回值的第一个字符串。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e注意：由于WATCH命令的作用只是当被监控的键被修改后取消之后的事务，并不能保证其他客户端不修改监控的值，所以当EXEC命令执行失败之后需要手动重新执行整个事务。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e执行EXEC命令之后会取消监控使用WATCH命令监控的键，如果不想执行事务中的命令，也可以使用UNWATCH命令来取消监控。\u003c/p\u003e\n\n\u003ch2 id=\"声明\"\u003e声明\u003c/h2\u003e\n\n\u003cp\u003e原创文章，转载请注明出处，本文链接：\u003ca href=\"http://qifuguang.me/2015/09/30/Redis%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/\"\u003ehttp://qifuguang.me/2015/09/30/Redis事务介绍/\u003c/a\u003e\u003c/p\u003e\n","location":"开发/Redis事务介绍","picture":"https://nanxi.li/开发/img/covers/juery.jpg","tags":["redis"],"title":"Redis事务介绍\n"}