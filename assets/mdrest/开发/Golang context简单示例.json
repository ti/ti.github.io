{"author":"Deepzz","author_link":"https://deepzz.com","date":"2017-02-27T00:00:00Z","html":"\u003cp\u003e对于 Golang 开发者来说 \u003ccode\u003econtext\u003c/code\u003e （上下文）包一定不会陌生。但很多时候，我们懒惰的只是见过它，或能起到什么作用，并不会去深究它。\u003c/p\u003e\n\n\u003cp\u003e应用场景：在 Go http 包的 Server 中，每一个请求在都有一个对应的 \u003ccode\u003egoroutine\u003c/code\u003e 去处理。请求处理函数通常会启动额外的 \u003ccode\u003egoroutine\u003c/code\u003e 用来访问后端服务，比如数据库和 RPC 服务。用来处理一个请求的 \u003ccode\u003egoroutine\u003c/code\u003e 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的 token、请求的截止时间。当一个请求被取消或超时时，所有用来处理该请求的\u003ccode\u003egoroutine\u003c/code\u003e 都应该迅速退出，然后系统才能释放这些 \u003ccode\u003egoroutine\u003c/code\u003e 占用的资源。\u003c/p\u003e\n\n\u003ch3 id=\"context-原理\"\u003eContext 原理\u003c/h3\u003e\n\n\u003cp\u003eContext 的调用应该是链式的，通过 \u003ccode\u003eWithCancel\u003c/code\u003e ， \u003ccode\u003eWithDeadline\u003c/code\u003e ， \u003ccode\u003eWithTimeout\u003c/code\u003e 或 \u003ccode\u003eWithValue\u003c/code\u003e 派生出新的 Context。当父 Context 被取消时，其派生的所有 Context 都将取消。\u003c/p\u003e\n\n\u003cp\u003e通过 \u003ccode\u003econtext.WithXXX\u003c/code\u003e 都将返回新的 Context 和 CancelFunc。调用 CancelFunc 将取消子代，移除父代对子代的引用，并且停止所有定时器。未能调用 CancelFunc 将泄漏子代，直到父代被取消或定时器触发。 \u003ccode\u003ego vet\u003c/code\u003e 工具检查所有流程控制路径上使用 CancelFuncs。\u003c/p\u003e\n\n\u003ch3 id=\"遵循规则\"\u003e遵循规则\u003c/h3\u003e\n\n\u003cp\u003e遵循以下规则，以保持包之间的接口一致，并启用静态分析工具以检查上下文传播。\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e不要将 Contexts 放入结构体，相反 \u003ccode\u003econtext\u003c/code\u003e 应该作为第一个参数传入，命名为 \u003ccode\u003ectx\u003c/code\u003e 。 \u003ccode\u003efunc DoSomething（ctx context.Context，arg Arg）error { // ... use ctx ... }\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e即使函数允许，也不要传入 \u003ccode\u003enil\u003c/code\u003e 的 Context。如果不知道用哪种 Context，可以使用 \u003ccode\u003econtext.TODO()\u003c/code\u003e 。\u003c/li\u003e\n\u003cli\u003e使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数\u003c/li\u003e\n\u003cli\u003e相同的 Context 可以传递给在不同的 \u003ccode\u003egoroutine\u003c/code\u003e ；Context 是并发安全的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"context-包\"\u003eContext 包\u003c/h3\u003e\n\n\u003cp\u003e结构体\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e// A Context carries a deadline, cancelation signal, and request-scoped values\n// across API boundaries. Its methods are safe for simultaneous use by multiple\n// goroutines.\ntype Context interface {\n    // Done returns a channel that is closed when this Context is canceled\n    // or times out.\n    Done() \u0026lt;-chan struct{}\n\n    // Err indicates why this context was canceled, after the Done channel\n    // is closed.\n    Err() error\n\n    // Deadline returns the time when this Context will be canceled, if any.\n    Deadline() (deadline time.Time, ok bool)\n\n    // Value returns the value associated with key or nil if none.\n    Value(key interface{}) interface{}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003eDone()，返回一个channel。当times out或者调用cancel方法时，将会close掉。\u003c/li\u003e\n\u003cli\u003eErr()，返回一个错误。该context为什么被取消掉。\u003c/li\u003e\n\u003cli\u003eDeadline()，返回截止时间和ok。\u003c/li\u003e\n\u003cli\u003eValue()，返回值。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e所有方法\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003eunc Background() Context\nfunc TODO() Context\n\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)\nfunc WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\nfunc WithValue(parent Context, key, val interface{}) Context\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e上面可以看到Context是一个接口，想要使用就得实现其方法。在context包内部已经为我们实现好了两个空的Context，可以通过调用Background()和TODO()方法获取。一般的将它们作为Context的根，往下派生。\u003c/p\u003e\n\n\u003ch3 id=\"withcancel-例子\"\u003eWithCancel 例子\u003c/h3\u003e\n\n\u003cp\u003eWithCancel 以一个新的 Done channel 返回一个父 Context 的拷贝。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc WithCancel(parent Context) (ctx Context, cancel CancelFunc) {\n         c := newCancelCtx(parent)\n         propagateCancel(parent, \u0026amp;c)\n         return \u0026amp;c, func() { c.cancel(true, Canceled) }\n     }\n     \n     // newCancelCtx returns an initialized cancelCtx.\n     func newCancelCtx(parent Context) cancelCtx {\n         return cancelCtx{\n             Context: parent,\n             done:    make(chan struct{}),\n         }\n     }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e此示例演示使用一个可取消的上下文，以防止 goroutine 泄漏。示例函数结束时，defer 调用 cancel 方法，gen goroutine 将返回而不泄漏。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003eackage main\n\nimport (\n    \u0026quot;context\u0026quot;\n    \u0026quot;fmt\u0026quot;\n)\n\nfunc main() {\n    // gen generates integers in a separate goroutine and\n    // sends them to the returned channel.\n    // The callers of gen need to cancel the context once\n    // they are done consuming generated integers not to leak\n    // the internal goroutine started by gen.\n    gen := func(ctx context.Context) \u0026lt;-chan int {\n        dst := make(chan int)\n        n := \n        go func() {\n            for {\n                select {\n                case \u0026lt;-ctx.Done():\n                    return // returning not to leak the goroutine\n                case dst \u0026lt;- n:\n                    n++\n                }\n            }\n        }()\n        return dst\n    }\n\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel() // cancel when we are finished consuming integers\n\n    for n := range gen(ctx) {\n        fmt.Println(n)\n        if n ==  {\n            break\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"withdeadline-例子\"\u003eWithDeadline 例子\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {\n         if cur, ok := parent.Deadline(); ok \u0026amp;\u0026amp; cur.Before(deadline) {\n             // The current deadline is already sooner than the new one.\n             return WithCancel(parent)\n         }\n         c := \u0026amp;timerCtx{\n             cancelCtx: newCancelCtx(parent),\n             deadline:  deadline,\n         }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e可以清晰的看到，当派生出的子 Context 的deadline在父Context之后，直接返回了一个父Context的拷贝。故语义上等效为父。\u003c/p\u003e\n\n\u003cp\u003eWithDeadline 的最后期限调整为不晚于 d 返回父上下文的副本。如果父母的截止日期已经早于 d，WithDeadline （父，d） 是在语义上等效为父。返回的上下文完成的通道关闭的最后期限期满后，返回的取消函数调用时，或当父上下文完成的通道关闭，以先发生者为准。\u003c/p\u003e\n\n\u003cp\u003e看看官方例子：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n    \u0026quot;context\u0026quot;\n    \u0026quot;fmt\u0026quot;\n    \u0026quot;time\u0026quot;\n)\n\nfunc main() {\n    d := time.Now().Add(50 * time.Millisecond)\n    ctx, cancel := context.WithDeadline(context.Background(), d)\n\n    // Even though ctx will be expired, it is good practice to call its\n    // cancelation function in any case. Failure to do so may keep the\n    // context and its parent alive longer than necessary.\n    defer cancel()\n\n    select {\n    case \u0026lt;-time.After(1 * time.Second):\n        fmt.Println(\u0026quot;overslept\u0026quot;)\n    case \u0026lt;-ctx.Done():\n        fmt.Println(ctx.Err())\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"withtimeout-例子\"\u003eWithTimeout 例子\u003c/h3\u003e\n\n\u003cp\u003eWithTimeout 返回 WithDeadline(parent, time.Now().Add(timeout))。\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {\n         return WithDeadline(parent, time.Now().Add(timeout))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e看看官方例子：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n    \u0026quot;context\u0026quot;\n    \u0026quot;fmt\u0026quot;\n    \u0026quot;time\u0026quot;\n)\n\nfunc main() {\n    // Pass a context with a timeout to tell a blocking function that it\n    // should abandon its work after the timeout elapses.\n    ctx, cancel := context.WithTimeout(context.Background(), *time.Millisecond)\n    defer cancel()\n\n    select {\n    case \u0026lt;-time.After( * time.Second):\n        fmt.Println(\u0026quot;overslept\u0026quot;)\n    case \u0026lt;-ctx.Done():\n        fmt.Println(ctx.Err()) // prints \u0026quot;context deadline exceeded\u0026quot;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"withvalue-例子\"\u003eWithValue 例子\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc WithValue(parent Context, key, val interface{}) Context {\n         if key == nil {\n             panic(\u0026quot;nil key\u0026quot;)\n         }\n         if !reflect.TypeOf(key).Comparable() {\n             panic(\u0026quot;key is not comparable\u0026quot;)\n         }\n         return \u0026amp;valueCtx{parent, key, val}\n     }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWithValue 返回的父与键关联的值在 val 的副本。\u003c/p\u003e\n\n\u003cp\u003e使用上下文值仅为过渡进程和 Api 的请求范围的数据，而不是将可选参数传递给函数。\u003c/p\u003e\n\n\u003cp\u003e提供的键必须是可比性和应该不是字符串类型或任何其他内置的类型以避免包使用的上下文之间的碰撞。WithValue 用户应该定义自己的键的类型。为了避免分配分配给接口 {} 时，上下文键经常有具体类型结构 {}。另外，导出的上下文关键变量静态类型应该是一个指针或接口。\u003c/p\u003e\n\n\u003cp\u003e看看官方例子：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport (\n    \u0026quot;context\u0026quot;\n    \u0026quot;fmt\u0026quot;\n)\n\nfunc main() {\n    type favContextKey string\n\n    f := func(ctx context.Context, k favContextKey) {\n        if v := ctx.Value(k); v != nil {\n            fmt.Println(\u0026quot;found value:\u0026quot;, v)\n            return\n        }\n        fmt.Println(\u0026quot;key not found:\u0026quot;, k)\n    }\n\n    k := favContextKey(\u0026quot;language\u0026quot;)\n    ctx := context.WithValue(context.Background(), k, \u0026quot;Go\u0026quot;)\n\n    f(ctx, k)\n    f(ctx, favContextKey(\u0026quot;color\u0026quot;))\n}\n\u003c/code\u003e\u003c/pre\u003e\n","location":"开发/Golang context简单示例","tags":["go","context"],"title":"Golang context 包，简单示例"}